[{"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\couplingPatterns.ts":"1","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\couplingValues.ts":"2","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\gyromagneticRatio.ts":"3","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\impurities.ts":"4","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\index.ts":"5","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\peaksFilterImpurities.ts":"6","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\peaksToRanges.ts":"7","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\determineRealTop.ts":"8","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\getKernel.ts":"9","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\jAnalyzer.ts":"10","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\joinRanges.ts":"11","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\peakOptimizer.ts":"12","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictAll.ts":"13","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictCarbon.ts":"14","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictCOSY.ts":"15","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictHMBC.ts":"16","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictHSQC.ts":"17","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictProton.ts":"18","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\fetchPrediction.ts":"19","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\flatGroupedDiaIDs.ts":"20","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getFilteredIDiaIDs.ts":"21","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getPredictions.ts":"22","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\predict2D.ts":"23","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\queryByHOSE.ts":"24","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictAll.test.ts":"25","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictCarbon.test.ts":"26","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictCOSY.test.ts":"27","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictHMBC.test.ts":"28","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictHSQC.test.ts":"29","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictProton.test.ts":"30","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\rangesToACS.ts":"31","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\__tests__\\rangesToACS.test.ts":"32","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\signalJoinCouplings.ts":"33","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\signalMultiplicityPattern.ts":"34","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\__tests__\\signalJoinCouplings.test.ts":"35","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\__tests__\\signalMultiplicityPattern.test.ts":"36","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\hackSignalsToXY.ts":"37","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signals2DToZ.ts":"38","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsJoin.ts":"39","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsToRanges.ts":"40","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsToXY.ts":"41","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\getPauliMatrix.ts":"42","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\signalsToSpinSystem.ts":"43","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\simulate1D.ts":"44","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\splitSpinSystem.ts":"45","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\__tests__\\splitSpinSystem.test.ts":"46","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsJoin.test.ts":"47","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsToRanges.test.ts":"48","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsToXY.test.ts":"49","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-matrix-convolution\\index.d.ts":"50","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-matrix-peaks-finder\\index.d.ts":"51","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-simple-clustering\\index.d.ts":"52","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-sparse-matrix\\index.d.ts":"53","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-spectra-processing\\index.d.ts":"54","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\joinPatterns.ts":"55","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\resurrect.ts":"56","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\splitPatterns.ts":"57","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\joinPatterns.test.ts":"58","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\resurrect.test.ts":"59","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\splitPatterns.test.ts":"60","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\xyAutoPeaksPicking.ts":"61","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\xyAutoRangesPicking.ts":"62","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\__tests__\\xyAutoPeaksPicking.test.ts":"63","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\__tests__\\xyAutoRangesPicking.test.ts":"64","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xyz\\xyzAutoPeaksPicking.ts":"65","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xyz\\xyzJResAnalyzer.ts":"66","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\rangesToXY.ts":"67","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\__tests__\\rangesToXY.test.ts":"68","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\resurrectRange.ts":"69","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\splitParenthesis.ts":"70","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\resurrectRange.test.ts":"71","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\carbonImpurities.ts":"72","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\DatabaseNMREntry.ts":"73","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\getDatabase.ts":"74","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\protonImpurities.ts":"75","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\__tests__\\getDatabase.test.ts":"76","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getNuclei.ts":"77","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\rangeFromSignal.ts":"78","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\rangeFromSignal.test.ts":"79","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\__tests__\\index.test.ts":"80","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-gsd\\index.d.ts":"81","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-levenberg-marquardt\\index.d.ts":"82","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\dataStructure.ts":"83","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\jcoupling.ts":"84","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\MakeMandatory.ts":"85","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\MPFPeak.ts":"86","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\nmrAssigment.ts":"87","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRPeak1D.ts":"88","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRRange.ts":"89","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRSignal1D.ts":"90","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRSignal2D.ts":"91","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRZone.ts":"92","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\openchemlib-utils\\index..d.ts":"93","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\prediction1D.ts":"94","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\prediction2D.ts":"95","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\spinSystem.ts":"96","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\XYNumberArray.ts":"97"},{"size":107,"mtime":1634741833131,"results":"98","hashOfConfig":"99"},{"size":180,"mtime":1634741833132,"results":"100","hashOfConfig":"99"},{"size":534,"mtime":1634741833133,"results":"101","hashOfConfig":"99"},{"size":54931,"mtime":1634741833135,"results":"102","hashOfConfig":"99"},{"size":1157,"mtime":1634741833148,"results":"103","hashOfConfig":"99"},{"size":2109,"mtime":1634742154384,"results":"104","hashOfConfig":"99"},{"size":10415,"mtime":1634821897267,"results":"105","hashOfConfig":"99"},{"size":4350,"mtime":1634821880731,"results":"106","hashOfConfig":"99"},{"size":848,"mtime":1634741833153,"results":"107","hashOfConfig":"99"},{"size":21203,"mtime":1634821876574,"results":"108","hashOfConfig":"99"},{"size":702,"mtime":1634741833157,"results":"109","hashOfConfig":"99"},{"size":10177,"mtime":1634741833159,"results":"110","hashOfConfig":"99"},{"size":3314,"mtime":1634741833169,"results":"111","hashOfConfig":"99"},{"size":4194,"mtime":1634822008352,"results":"112","hashOfConfig":"99"},{"size":2170,"mtime":1634821856658,"results":"113","hashOfConfig":"99"},{"size":2260,"mtime":1634821839617,"results":"114","hashOfConfig":"99"},{"size":2133,"mtime":1634821834590,"results":"115","hashOfConfig":"99"},{"size":3106,"mtime":1634744420827,"results":"116","hashOfConfig":"99"},{"size":765,"mtime":1634741833176,"results":"117","hashOfConfig":"99"},{"size":294,"mtime":1634741833177,"results":"118","hashOfConfig":"99"},{"size":1383,"mtime":1634741833178,"results":"119","hashOfConfig":"99"},{"size":677,"mtime":1634741833181,"results":"120","hashOfConfig":"99"},{"size":9951,"mtime":1634822098408,"results":"121","hashOfConfig":"99"},{"size":1322,"mtime":1634744420826,"results":"122","hashOfConfig":"99"},{"size":4867,"mtime":1634741833161,"results":"123","hashOfConfig":"99"},{"size":2127,"mtime":1634742154388,"results":"124","hashOfConfig":"99"},{"size":1812,"mtime":1634741833163,"results":"125","hashOfConfig":"99"},{"size":1278,"mtime":1634741833166,"results":"126","hashOfConfig":"99"},{"size":1042,"mtime":1634741833167,"results":"127","hashOfConfig":"99"},{"size":4622,"mtime":1634821864158,"results":"128","hashOfConfig":"99"},{"size":7890,"mtime":1634821816718,"results":"129","hashOfConfig":"99"},{"size":2464,"mtime":1634741833185,"results":"130","hashOfConfig":"99"},{"size":4399,"mtime":1634821812098,"results":"131","hashOfConfig":"99"},{"size":412,"mtime":1634741833197,"results":"132","hashOfConfig":"99"},{"size":2099,"mtime":1634744420826,"results":"133","hashOfConfig":"99"},{"size":285,"mtime":1634741833194,"results":"134","hashOfConfig":"99"},{"size":2271,"mtime":1634821793399,"results":"135","hashOfConfig":"99"},{"size":1722,"mtime":1634821785789,"results":"136","hashOfConfig":"99"},{"size":4050,"mtime":1634744420826,"results":"137","hashOfConfig":"99"},{"size":1972,"mtime":1634821761873,"results":"138","hashOfConfig":"99"},{"size":3020,"mtime":1634821742666,"results":"139","hashOfConfig":"99"},{"size":1095,"mtime":1634741833211,"results":"140","hashOfConfig":"99"},{"size":2495,"mtime":1634821727335,"results":"141","hashOfConfig":"99"},{"size":10004,"mtime":1634821699975,"results":"142","hashOfConfig":"99"},{"size":5185,"mtime":1634741833214,"results":"143","hashOfConfig":"99"},{"size":5032,"mtime":1634821734404,"results":"144","hashOfConfig":"99"},{"size":790,"mtime":1634744420826,"results":"145","hashOfConfig":"99"},{"size":1716,"mtime":1634741833199,"results":"146","hashOfConfig":"99"},{"size":3281,"mtime":1634821802669,"results":"147","hashOfConfig":"99"},{"size":445,"mtime":1634823358065,"results":"148","hashOfConfig":"99"},{"size":583,"mtime":1634823362316,"results":"149","hashOfConfig":"99"},{"size":300,"mtime":1634823366582,"results":"150","hashOfConfig":"99"},{"size":1132,"mtime":1634823370532,"results":"151","hashOfConfig":"99"},{"size":1260,"mtime":1634823374405,"results":"152","hashOfConfig":"99"},{"size":572,"mtime":1634741833245,"results":"153","hashOfConfig":"99"},{"size":2549,"mtime":1634741833248,"results":"154","hashOfConfig":"99"},{"size":273,"mtime":1634741833252,"results":"155","hashOfConfig":"99"},{"size":138,"mtime":1634741833240,"results":"156","hashOfConfig":"99"},{"size":2345,"mtime":1634741833243,"results":"157","hashOfConfig":"99"},{"size":383,"mtime":1634741833245,"results":"158","hashOfConfig":"99"},{"size":5770,"mtime":1634742154397,"results":"159","hashOfConfig":"99"},{"size":957,"mtime":1634741833257,"results":"160","hashOfConfig":"99"},{"size":2530,"mtime":1634742154394,"results":"161","hashOfConfig":"99"},{"size":1061,"mtime":1634742154395,"results":"162","hashOfConfig":"99"},{"size":9939,"mtime":1634821951835,"results":"163","hashOfConfig":"99"},{"size":6648,"mtime":1634821940403,"results":"164","hashOfConfig":"99"},{"size":4395,"mtime":1634741833190,"results":"165","hashOfConfig":"99"},{"size":1731,"mtime":1634741833187,"results":"166","hashOfConfig":"99"},{"size":2682,"mtime":1634741833249,"results":"167","hashOfConfig":"99"},{"size":352,"mtime":1634741833251,"results":"168","hashOfConfig":"99"},{"size":1152,"mtime":1634741833244,"results":"169","hashOfConfig":"99"},{"size":227064,"mtime":1634741833141,"results":"170","hashOfConfig":"99"},{"size":238,"mtime":1634823164436,"results":"171","hashOfConfig":"99"},{"size":2152,"mtime":1634741833143,"results":"172","hashOfConfig":"99"},{"size":284098,"mtime":1634741833146,"results":"173","hashOfConfig":"99"},{"size":1004,"mtime":1634741833139,"results":"174","hashOfConfig":"99"},{"size":209,"mtime":1634741833180,"results":"175","hashOfConfig":"99"},{"size":998,"mtime":1634741833246,"results":"176","hashOfConfig":"99"},{"size":835,"mtime":1634741833241,"results":"177","hashOfConfig":"99"},{"size":818,"mtime":1634742154382,"results":"178","hashOfConfig":"99"},{"size":3948,"mtime":1634823347191,"results":"179","hashOfConfig":"99"},{"size":342,"mtime":1634823352650,"results":"180","hashOfConfig":"99"},{"size":141,"mtime":1634823071196,"results":"181","hashOfConfig":"99"},{"size":172,"mtime":1634823075150,"results":"182","hashOfConfig":"99"},{"size":76,"mtime":1634823082855,"results":"183","hashOfConfig":"99"},{"size":132,"mtime":1634823086722,"results":"184","hashOfConfig":"99"},{"size":779,"mtime":1634823090868,"results":"185","hashOfConfig":"99"},{"size":173,"mtime":1634823094433,"results":"186","hashOfConfig":"99"},{"size":249,"mtime":1634823098037,"results":"187","hashOfConfig":"99"},{"size":433,"mtime":1634823633130,"results":"188","hashOfConfig":"99"},{"size":369,"mtime":1634823104749,"results":"189","hashOfConfig":"99"},{"size":175,"mtime":1634823109004,"results":"190","hashOfConfig":"99"},{"size":3722,"mtime":1634823383343,"results":"191","hashOfConfig":"99"},{"size":335,"mtime":1634823112072,"results":"192","hashOfConfig":"99"},{"size":0,"mtime":1634823115652,"results":"193","hashOfConfig":"99"},{"size":205,"mtime":1634823118759,"results":"194","hashOfConfig":"99"},{"size":105,"mtime":1634823121890,"results":"195","hashOfConfig":"99"},{"filePath":"196","messages":"197","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1j1uegp",{"filePath":"198","messages":"199","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"200","messages":"201","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"202"},{"filePath":"203","messages":"204","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"205","messages":"206","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"207","messages":"208","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"209","messages":"210","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211"},{"filePath":"212","messages":"213","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"214"},{"filePath":"215","messages":"216","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"217","messages":"218","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"219","messages":"220","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"221","messages":"222","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"223"},{"filePath":"224","messages":"225","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"226"},{"filePath":"227","messages":"228","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"229","messages":"230","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"231","messages":"232","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"233","messages":"234","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"235","messages":"236","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"237"},{"filePath":"238","messages":"239","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"240","messages":"241","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"242","messages":"243","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"244"},{"filePath":"245","messages":"246","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"247"},{"filePath":"248","messages":"249","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"250"},{"filePath":"251","messages":"252","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"253","messages":"254","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"255","messages":"256","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"257","messages":"258","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"259","messages":"260","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"261","messages":"262","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"263","messages":"264","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"265"},{"filePath":"266","messages":"267","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"268"},{"filePath":"269","messages":"270","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"271","messages":"272","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"273"},{"filePath":"274","messages":"275","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"276","messages":"277","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"278","messages":"279","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"280","messages":"281","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"282","messages":"283","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"284","messages":"285","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"286","messages":"287","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"288","messages":"289","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"290","messages":"291","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"292","messages":"293","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"294","messages":"295","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"296"},{"filePath":"297","messages":"298","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"299","messages":"300","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"301","messages":"302","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"303","messages":"304","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"305","messages":"306","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"307","messages":"308","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"309","messages":"310","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"311","messages":"312","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"313","messages":"314","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"315","messages":"316","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"317","messages":"318","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"319","messages":"320","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"321"},{"filePath":"322","messages":"323","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"324"},{"filePath":"325","messages":"326","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"327","messages":"328","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"329"},{"filePath":"330","messages":"331","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"332","messages":"333","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"334","messages":"335","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"336","messages":"337","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"338"},{"filePath":"339","messages":"340","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"341","messages":"342","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"343"},{"filePath":"344","messages":"345","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"346"},{"filePath":"347","messages":"348","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"349"},{"filePath":"350","messages":"351","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"352"},{"filePath":"353","messages":"354","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"355"},{"filePath":"356","messages":"357","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"358","messages":"359","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"360","messages":"361","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"362","messages":"363","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"364","messages":"365","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"366","messages":"367","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"368","messages":"369","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"370","messages":"371","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"372","messages":"373","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"374"},{"filePath":"375","messages":"376","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"377","messages":"378","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"379","messages":"380","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"381","messages":"382","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"383"},{"filePath":"384","messages":"385","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"386","messages":"387","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"388","messages":"389","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"390","messages":"391","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"392","messages":"393","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"394","messages":"395","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"396","messages":"397","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"398","messages":"399","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"400","messages":"401","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"402","messages":"403","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"404","messages":"405","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"406","messages":"407","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"408","messages":"409","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"410","messages":"411","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"412","messages":"413","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\couplingPatterns.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\couplingValues.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\gyromagneticRatio.ts",["414"],"// sources:\n// https://en.wikipedia.org/wiki/Gyromagnetic_ratio\n\n// TODO: #13 can we have a better source and more digits ? @jwist\n\nexport const gyromagneticRatio = {\n  '1H': 267.52218744e6,\n  '2H': 41.065e6,\n  '3H': 285.3508e6,\n  '3He': -203.789e6,\n  '7Li': 103.962e6,\n  '13C': 67.28284e6,\n  '14N': 19.331e6,\n  '15N': -27.116e6,\n  '17O': -36.264e6,\n  '19F': 251.662e6,\n  '23Na': 70.761e6,\n  '27Al': 69.763e6,\n  '29Si': -53.19e6,\n  '31P': 108.291e6,\n  '57Fe': 8.681e6,\n  '63Cu': 71.118e6,\n  '67Zn': 16.767e6,\n  '129Xe': -73.997e6,\n};\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\constants\\impurities.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\index.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\peaksFilterImpurities.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\peaksToRanges.ts",["415","416"],"import type { DataXY } from 'cheminfo-types';\nimport type { GSDPeak } from 'ml-gsd';\nimport { xyIntegration } from 'ml-spectra-processing';\n\nimport type { MakeMandatory } from '../types/MakeMandatory';\nimport type { NMRPeak1D } from '../types/NMRPeak1D';\nimport type { NMRRange } from '../types/NMRRange';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\n\nimport jAnalyzer from './util/jAnalyzer';\nimport type { SignalIntern, Peak1DIntern } from './util/jAnalyzer';\nimport { joinRanges } from './util/joinRanges';\n\nexport interface OptionsPeaksToRanges {\n  /**\n   * Number of hydrogens or some number to normalize the integration data. If it's zero return the absolute integration value\n   * @default 100\n   */\n  integrationSum?: number;\n  /**\n   * if it is true, it will join any overlaped ranges.\n   * @default true\n   */\n  joinOverlapRanges?: boolean;\n  /**\n   * If exits it remove all the signals with integration < clean value\n   * @default 0.4\n   */\n  clean?: number;\n  /**\n   * If true, the Janalyzer function is run over signals to compile the patterns.\n   * @default true\n   */\n  compile?: boolean;\n  /**\n   * option to chose between approx area with peaks or the sum of the points of given range ('sum', 'peaks')\n   * @default 'sum'\n   */\n  integralType?: string;\n  /**\n   * Observed frequency\n   * @default 400\n   */\n  frequency?: number;\n  /**\n   * distance limit to clustering peaks.\n   * @default 16\n   */\n  frequencyCluster?: number;\n  /**\n   * If true, it will keep the peaks for each signal\n   */\n  keepPeaks?: boolean;\n  /**\n   * Nucleus\n   * @default '1H'\n   */\n  nucleus?: string;\n}\n\nexport interface OptionsDetectSignals {\n  integrationSum?: number;\n  integralType?: string;\n  frequencyCluster?: number;\n  frequency?: number;\n  nucleus?: string;\n}\n\ntype SignalInternMandatory = MakeMandatory<\n  SignalIntern,\n  'symRank' | 'mask' | 'peaksComp' | 'mask2' | 'maskPattern'\n>;\n\nfunction checkSignalAfterCompilePattern(\n  signal: SignalIntern,\n): asserts signal is SignalInternMandatory {\n  // if (!signal.symRank)\n  //   throw new Error('Internal error, symRank was not calculated');\n  if (!signal.mask) throw new Error('Internal Error, mask was not added');\n  if (!signal.mask2) throw new Error('Internal Error, mask2 was not added');\n  if (!signal.maskPattern) {\n    throw new Error('Internal Error, maskPattern was not added');\n  }\n}\n\nconst assignSignal = (\n  peak: NMRPeak1D,\n  frequency: number,\n  nucleus: string,\n): SignalIntern => {\n  return {\n    delta: NaN,\n    nbPeaks: 1,\n    kind: 'signal',\n    startX: peak.x - peak.shape.width,\n    stopX: peak.x + peak.shape.width,\n    observe: frequency,\n    nucleus,\n    integralData: {\n      from: peak.x - peak.shape.width * 3,\n      to: peak.x + peak.shape.width * 3,\n      value: 0,\n    },\n    peaks: [\n      {\n        x: peak.x,\n        intensity: peak.y,\n        shape: {\n          width: peak.shape.width,\n        },\n      },\n    ],\n  };\n};\n/**\n * This function clustering peaks and calculate the integration value for each range from the peak list returned from extractPeaks function.\n */\n\nexport function peaksToRanges(\n  data: DataXY,\n  peakList: NMRPeak1D[],\n  options: OptionsPeaksToRanges = {},\n): NMRRange[] {\n  let {\n    integrationSum = 100,\n    joinOverlapRanges = true,\n    clean = 0.4,\n    compile = true,\n    integralType = 'sum',\n    frequency = 400,\n    frequencyCluster = 16,\n    keepPeaks = false,\n    nucleus = '1H',\n  } = options;\n\n  let signalOptions = {\n    integrationSum,\n    integralType,\n    frequencyCluster,\n    frequency,\n    nucleus,\n  };\n\n  if (data.x[0] > data.x[1]) {\n    data.x = data.x.reverse();\n    data.y = data.y.reverse();\n  }\n\n  let signals = detectSignals(data, peakList, signalOptions);\n\n  if (clean) {\n    for (let i = 0; i < signals.length; i++) {\n      if (Math.abs(signals[i].integralData.value) < clean) {\n        signals.splice(i, 1);\n      }\n    }\n  }\n\n  if (compile) {\n    let nHi, sum;\n    for (let i = 0; i < signals.length; i++) {\n      signals[i] = jAnalyzer.compilePattern(signals[i]);\n      let signal = signals[i];\n      if (\n        signal.maskPattern &&\n        signal.multiplicity !== 'm' &&\n        signal.multiplicity !== ''\n      ) {\n        checkSignalAfterCompilePattern(signal);\n        // Create a new signal with the removed peaks\n        nHi = 0;\n        sum = 0;\n        let peaksO = [];\n        for (let j = signal.maskPattern.length - 1; j >= 0; j--) {\n          sum += computeArea(signal.peaks[j]);\n          if (signal.maskPattern[j] === false) {\n            let peakR = signal.peaks.splice(j, 1)[0];\n            peaksO.push({\n              x: peakR.x,\n              y: peakR.intensity,\n              shape: {\n                width: peakR.shape.width,\n              },\n            });\n            signal.mask.splice(j, 1);\n            signal.mask2.splice(j, 1);\n            signal.maskPattern.splice(j, 1);\n            signal.nbPeaks--;\n            nHi += computeArea(peakR);\n          }\n        }\n        if (peaksO.length > 0) {\n          nHi = (nHi * signal.integralData.value) / sum;\n          signal.integralData.value -= nHi;\n          let peaks1 = [];\n          for (let j = peaksO.length - 1; j >= 0; j--) {\n            peaks1.push(peaksO[j]);\n          }\n          signalOptions.integrationSum = Math.abs(nHi);\n          let ranges = detectSignals(data, peaks1, signalOptions);\n\n          for (const range of ranges) {\n            signals.push(range);\n          }\n        }\n      }\n    }\n    // it was a updateIntegrals function.\n    let sumIntegral = 0;\n    let sumObserved = 0;\n    for (const signal of signals) {\n      sumObserved += Math.abs(Math.round(signal.integralData.value));\n    }\n    if (sumObserved !== integrationSum) {\n      sumIntegral = integrationSum / sumObserved;\n      for (const signal of signals) {\n        signal.integralData.value *= sumIntegral;\n      }\n    }\n  }\n\n  signals.sort((a, b) => {\n    return b.delta - a.delta;\n  });\n\n  if (clean) {\n    for (let i = signals.length - 1; i >= 0; i--) {\n      if (Math.abs(signals[i].integralData.value) < clean) {\n        signals.splice(i, 1);\n      }\n    }\n  }\n\n  let ranges: NMRRange[] = [];\n  for (let i = 0; i < signals.length; i++) {\n    let signal = signals[i];\n    const range: NMRRange = {\n      from: signal.integralData.from,\n      to: signal.integralData.to,\n      integration: signal.integralData.value,\n    };\n    const signalResult: NMRSignal1D = {\n      delta: signal.delta,\n      kind: signal.kind || 'signal',\n      multiplicity: signal.multiplicity,\n    };\n    if (keepPeaks) {\n      signalResult.peaks = signal.peaks.map((peak) => {\n        const newResult: any = {\n          y: peak.intensity,\n          ...peak,\n        };\n        delete newResult.intensity;\n        return newResult as GSDPeak;\n      });\n    }\n    if (signal.nmrJs) {\n      signalResult.js = signal.nmrJs;\n    }\n\n    range.signals = [signalResult];\n    ranges[i] = range;\n  }\n\n  if (joinOverlapRanges) ranges = joinRanges(ranges);\n  // return new Ranges(ranges);\n  return ranges;\n}\n\n/**\n * Extract the signals from the peakList and the given spectrum.\n * @param {object} data - spectra data\n * @param {array} peakList - nmr signals\n * @param {object} [options = {}]\n * @param {number} [options.integrationSum='100'] - Number of hydrogens or some number to normalize the integration data, If it's zero return the absolute integration value\n * @param {string} [options.integralType='sum'] - option to chose between approx area with peaks or the sum of the points of given range\n * @param {number} [options.frequencyCluster=16] - distance limit to clustering the peaks.\n * range = frequencyCluster / observeFrequency -> Peaks withing this range are considered to belongs to the same signal1D\n * @param {string} [options.nucleus='1H'] - - Nucleus\n * @param {String} [options.frequency = 400] - Observed frequency\n * @return {array} nmr signals\n * @private\n */\n\nfunction detectSignals(\n  data: DataXY,\n  peakList: NMRPeak1D[],\n  options: OptionsDetectSignals = {},\n): SignalIntern[] {\n  let {\n    integrationSum = 100,\n    integralType = 'sum',\n    frequencyCluster = 16,\n    frequency = 400,\n    nucleus = '1H',\n  } = options;\n\n  let signal1D: SignalIntern = assignSignal(peakList[0], frequency, nucleus);\n  let peaks;\n  let signals = [];\n  let prevPeak = { x: Number.MIN_SAFE_INTEGER };\n  let spectrumIntegral = 0;\n  frequencyCluster /= frequency;\n  for (const peak of peakList) {\n    if (Math.abs(peak.x - prevPeak.x) > frequencyCluster) {\n      signal1D = assignSignal(peak, frequency, nucleus);\n      if (peak.kind) signal1D.kind = peak.kind;\n      signals.push(signal1D);\n    } else {\n      let tmp = peak.x + peak.shape.width;\n      signal1D.stopX = Math.max(signal1D.stopX, tmp);\n      signal1D.startX = Math.min(signal1D.startX, tmp);\n      signal1D.nbPeaks++;\n      signal1D.peaks.push({\n        x: peak.x,\n        intensity: peak.y,\n        shape: {\n          width: peak.shape.width,\n        },\n      });\n      signal1D.integralData.from = Math.min(\n        signal1D.integralData.from,\n        peak.x - peak.shape.width * 3,\n      );\n      signal1D.integralData.to = Math.max(\n        signal1D.integralData.to,\n        peak.x + peak.shape.width * 3,\n      );\n      if (peak.kind) signal1D.kind = peak.kind;\n    }\n    prevPeak = peak;\n  }\n  for (let signal of signals) {\n    peaks = signal.peaks;\n    let integration = signal.integralData;\n    let chemicalShift = 0;\n    let integralPeaks = 0;\n\n    for (const peak of peaks) {\n      let area = computeArea(peak);\n      chemicalShift += peak.x * area;\n      integralPeaks += area;\n    }\n    signal.delta = chemicalShift / integralPeaks;\n\n    if (integralType === 'sum') {\n      integration.value = xyIntegration(data, {\n        from: integration.from,\n        to: integration.to,\n      });\n    } else {\n      integration.value = integralPeaks;\n    }\n    spectrumIntegral += integration.value;\n  }\n\n  if (integrationSum > 0) {\n    let integralFactor = integrationSum / spectrumIntegral;\n    for (let signal of signals) {\n      let integration = signal.integralData;\n      integration.value *= integralFactor;\n    }\n  }\n\n  return signals;\n}\n\n/**\n * Return the area of a Lorentzian function\n * @param {object} peak - object with peak information\n * @return {Number}\n * @private\n */\nfunction computeArea(peak: Peak1DIntern) {\n  return Math.abs(peak.intensity * peak.shape.width * 1.57); // todo add an option with this value: 1.772453851\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\determineRealTop.ts",["417"],"import LM from 'ml-levenberg-marquardt';\nimport { gaussian2D } from 'ml-peak-shape-generator';\n\nimport type { MPFPeak } from '../../types/MPFPeak';\n\nconst { fct: gaussian2DFct } = gaussian2D;\n\nconst direction8X = [-1, -1, -1, 0, 0, 1, 1, 1];\nconst direction8Y = [-1, 0, 1, -1, 1, -1, 0, 1];\nconst direction16X = [-2, -2, -2, -2, -2, -1, -1, 0, 0, 1, 1, 2, 2, 2, 2, 2];\nconst direction16Y = [-2, -1, 0, 1, 2, -2, 2, -2, 2, -2, 2, -2, -1, 0, 1, 2];\n\ntype Data = number[] | Float64Array;\n\nexport function determineRealTop(peaks: MPFPeak[], options: any) {\n  let { nCols, absoluteData, originalData, minX, maxX, minY, maxY } = options;\n  for (let i = 0; i < peaks.length; i++) {\n    let xIndex = Math.round(peaks[i].x);\n    let yIndex = Math.round(peaks[i].y);\n\n    let currentIndex = xIndex + yIndex * nCols;\n    let { index, isMax } = determineMax(absoluteData, {\n      xIndex,\n      yIndex,\n      nCols,\n      shell: 1,\n    });\n    currentIndex = isMax\n      ? index\n      : determineMax(absoluteData, {\n          xIndex,\n          yIndex,\n          nCols,\n          shell: 2,\n        }).index;\n\n    let realTopCoordinates = fitGaussian(originalData, {\n      nCols,\n      index: currentIndex,\n      minY,\n      maxY,\n      minX,\n      maxX,\n    });\n\n    peaks[i] = Object.assign(peaks[i], realTopCoordinates);\n  }\n  return peaks;\n}\n\nfunction determineMax(\n  data: Data,\n  options: { xIndex: number; yIndex: number; shell: number; nCols: number },\n) {\n  let { xIndex, yIndex, shell, nCols } = options;\n  let currentIndex = xIndex + yIndex * nCols;\n  let [directionX, directionY] =\n    shell > 1 ? [direction16X, direction16Y] : [direction8X, direction8Y];\n\n  let isMax = false;\n  for (let i = 0; i < directionX.length; i++) {\n    let c = xIndex + directionX[i];\n    let r = yIndex + directionY[i];\n    if (data[c + r * nCols] >= data[currentIndex]) {\n      isMax = true;\n      let candidateIndex = c + r * nCols;\n      for (let k = 0; k < direction8Y.length; k++) {\n        let nc = c + direction8X[k];\n        let nr = r + direction8Y[k];\n        if (data[nc + nr * nCols] > data[candidateIndex]) {\n          isMax = false;\n          break;\n        }\n      }\n      if (isMax) {\n        currentIndex = candidateIndex;\n      }\n    }\n  }\n\n  return { index: currentIndex, isMax };\n}\n\nfunction fitGaussian(\n  data: number[] | Float64Array,\n  options: {\n    nCols: number;\n    index: number;\n    minY: number;\n    maxY: number;\n    minX: number;\n    maxX: number;\n  },\n) {\n  let { nCols, index, minY, maxY, minX, maxX } = options;\n\n  let nRows = data.length / nCols;\n\n  let intervalX = (maxX - minX) / (nCols - 1);\n  let intervalY = (maxY - minY) / (nRows - 1);\n\n  let col = index % nCols;\n  let row = (index - col) / nCols;\n\n  let newCol = 1;\n  let newRow = 1;\n\n  let max = Number.MIN_SAFE_INTEGER;\n  let z = new Array(direction8X.length + 1);\n  let xAxis = new Array(direction8X.length + 1);\n  for (let i = -1, xi = 0; i < 2; i++) {\n    for (let j = -1; j < 2; j++, xAxis[xi] = xi++) {\n      let value = data[col + j + (row + i) * nCols];\n      if (max < value) max = value;\n      z[newCol + j + (newRow + i) * 3] = value;\n    }\n  }\n\n  for (let i = 0; i < z.length; i++) z[i] /= max;\n\n  let maxValues = [newCol + 1, newRow + 1, 1.5, 1, 1];\n  let minValues = [newCol - 1, newRow - 1, -1.5, 0.001, 0.001];\n  let initialValues = [newCol, newRow, z[newCol + newRow * 3], 0.2, 0.2];\n  let gradientDifference = [1e-4, 1e-4, 1e-3, 1e-3, 1e-3];\n  let func = paramGaussian2D(intervalX, intervalY, 3);\n\n  let pFit = LM({ x: xAxis, y: z }, func, {\n    damping: 1.5,\n    maxIterations: 100,\n    errorTolerance: 1e-8,\n    initialValues,\n    gradientDifference,\n    maxValues,\n    minValues,\n  }).parameterValues;\n\n  return {\n    x: pFit[0] + col - 1,\n    y: pFit[1] + row - 1,\n    z: pFit[2] * max,\n  };\n}\n\nfunction paramGaussian2D(intervalX: number, intervalY: number, nCols: number) {\n  return (p: number[]) => {\n    return (t: number) => {\n      let nL = p.length / 5;\n      let result = 0;\n      let xIndex = t % nCols;\n      let yIndex = (t - xIndex) / nCols;\n      for (let i = 0; i < nL; i++) {\n        result +=\n          p[i + 2 * nL] *\n          gaussian2DFct(\n            (xIndex - p[i]) * intervalX,\n            (yIndex - p[i + nL]) * intervalY,\n            p[i + 3 * nL],\n            p[i + 4 * nL],\n          );\n      }\n      return result;\n    };\n  };\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\getKernel.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\jAnalyzer.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\joinRanges.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\peaks\\util\\peakOptimizer.ts",["418"],"import type { MPFPeak } from '../../types/MPFPeak';\nimport type { NMRSignal2D } from '../../types/NMRSignal2D';\n\nlet diagonalError = 0.05;\nlet tolerance = 0.05;\n\nexport function clean(peaks: MPFPeak[], threshold: number) {\n  let max = Number.NEGATIVE_INFINITY;\n  // double min = Double.MAX_VALUE;\n  for (let i = peaks.length - 1; i >= 0; i--) {\n    if (Math.abs(peaks[i].z) > max) {\n      max = Math.abs(peaks[i].z);\n    }\n  }\n  max *= threshold;\n  for (let i = peaks.length - 1; i >= 0; i--) {\n    if (Math.abs(peaks[i].z) < max) {\n      peaks.splice(i, 1);\n    }\n  }\n  return peaks;\n}\n\nexport function enhanceSymmetry(signals: NMRSignal2D[]) {\n  let properties = initializeProperties(signals);\n  let output = signals.slice();\n\n  // First step of the optimization: Symmetry validation\n  let hits;\n  for (let i = output.length - 1; i >= 0; i--) {\n    let signal = output[i];\n    if (signal.peaks && signal.peaks.length > 1) {\n      properties[i][1]++;\n    }\n    if (properties[i][0] === 1) {\n      let index = exist(output, properties, signal, -1, true);\n      if (index >= 0) {\n        properties[i][1] += 2;\n        properties[index][1] += 2;\n      }\n    }\n  }\n  // Second step of the optimization: Diagonal image existence\n  for (let i = output.length - 1; i >= 0; i--) {\n    let signal = output[i];\n    if (properties[i][0] === 0) {\n      hits = checkCrossPeaks(output, properties, signal, true);\n      properties[i][1] += hits;\n      // checkCrossPeaks(output, properties, signal, false);\n    }\n  }\n\n  // Now, each peak have a score between 0 and 4, we can complete the patterns which\n  // contains peaks with high scores, and finally, we can remove peaks with scores 0 and 1\n  let count = 0;\n  for (let i = output.length - 1; i >= 0; i--) {\n    if (properties[i][0] !== 0 && properties[i][1] > 2) {\n      count++;\n      count += completeMissingIfNeeded(\n        output,\n        properties,\n        output[i],\n        properties[i],\n      );\n    }\n    if (properties[i][1] >= 2 && properties[i][0] === 0) {\n      count++;\n    }\n  }\n\n  let toReturn = new Array(count);\n  count--;\n  for (let i = output.length - 1; i >= 0; i--) {\n    if (\n      (properties[i][0] !== 0 && properties[i][1] > 2) ||\n      (properties[i][0] === 0 && properties[i][1] > 1)\n    ) {\n      toReturn[count--] = output[i];\n    }\n  }\n  return toReturn;\n}\n\n// export function alignDimensions(signals2D, references) {\n//   // For each reference dimension\n//   for (let i = 0; i < references.length; i++) {\n//     let ref = references[i];\n//     if (ref) {\n//       alignSingleDimension(signals2D, ref);\n//     }\n//   }\n// }\n\nfunction completeMissingIfNeeded(\n  output: NMRSignal2D[],\n  properties: number[][],\n  thisSignal: NMRSignal2D,\n  thisProp: number[],\n) {\n  // Check for symmetry\n  let index = exist(output, properties, thisSignal, -thisProp[0], true);\n  let addedPeaks = 0;\n  let newSignal: any;\n  let tmpProp = null;\n  if (index < 0) {\n    // If this signal have no a symmetry image, we have to include it\n    newSignal = {\n      x: {\n        nucleus: thisSignal.x.nucleus,\n        resolution: thisSignal.x.resolution,\n        delta: thisSignal.y.delta,\n      },\n      y: {\n        nucleus: thisSignal.y.nucleus,\n        resolution: thisSignal.y.resolution,\n        delta: thisSignal.x.delta,\n      },\n      peaks: [{ x: thisSignal.y.delta, y: thisSignal.x.delta, z: 1 }],\n    };\n    output.push(newSignal);\n    tmpProp = [-thisProp[0], thisProp[1]];\n    properties.push(tmpProp);\n    addedPeaks++;\n  }\n  // Check for diagonal peaks\n  let signal;\n  let diagX = false;\n  let diagY = false;\n  for (let j = output.length - 1; j >= 0; j--) {\n    signal = output[j];\n    if (properties[j][0] === 0) {\n      if (Math.abs(signal.x.delta - thisSignal.x.delta) < diagonalError) {\n        diagX = true;\n      }\n      if (Math.abs(signal.y.delta - thisSignal.y.delta) < diagonalError) {\n        diagY = true;\n      }\n    }\n  }\n  if (diagX === false) {\n    newSignal = {\n      x: {\n        delta: thisSignal.y.delta,\n        nucleus: thisSignal.x.nucleus,\n        resolution: thisSignal.x.resolution,\n      },\n      y: {\n        delta: thisSignal.x.delta,\n        nucleus: thisSignal.y.nucleus,\n        resolution: thisSignal.y.resolution,\n      },\n      peaks: [{ x: thisSignal.x.delta, y: thisSignal.x.delta, z: 1 }],\n    };\n    newSignal.peaks = [{ x: thisSignal.x.delta, y: thisSignal.x.delta, z: 1 }]\n    output.push(newSignal);\n    tmpProp = [0, thisProp[1]];\n    properties.push(tmpProp);\n    addedPeaks++;\n  }\n  if (diagY === false) {\n    newSignal = {\n      x: {\n        delta: thisSignal.y.delta,\n        nucleus: thisSignal.x.nucleus,\n        resolution: thisSignal.x.resolution,\n      },\n      y: {\n        delta: thisSignal.y.delta,\n        nucleus: thisSignal.y.nucleus,\n        resolution: thisSignal.y.resolution,\n      },\n      peaks: [{ x: thisSignal.y.delta, y: thisSignal.y.delta, z: 1 }],\n    };\n    output.push(newSignal);\n    tmpProp = [0, thisProp[1]];\n    properties.push(tmpProp);\n    addedPeaks++;\n  }\n  return addedPeaks;\n}\n\n// Check for any diagonal peak that match this cross peak\nfunction checkCrossPeaks(\n  output: NMRSignal2D[],\n  properties: number[][],\n  signal: NMRSignal2D,\n  updateProperties: boolean,\n) {\n  let hits = 0;\n  let shift = signal.x.delta * 4;\n  let crossPeaksX = [];\n  let crossPeaksY = [];\n  let cross;\n  for (let i = output.length - 1; i >= 0; i--) {\n    cross = output[i];\n    if (properties[i][0] !== 0) {\n      if (Math.abs(cross.x.delta - signal.x.delta) < diagonalError) {\n        hits++;\n        if (updateProperties) {\n          properties[i][1]++;\n        }\n        crossPeaksX.push(i);\n        shift += cross.x.delta;\n      } else {\n        if (Math.abs(cross.y.delta - signal.y.delta) < diagonalError) {\n          hits++;\n          if (updateProperties) {\n            properties[i][1]++;\n          }\n          crossPeaksY.push(i);\n          shift += cross.y.delta;\n        }\n      }\n    }\n  }\n  // Update found crossPeaks and diagonal peak\n  shift /= crossPeaksX.length + crossPeaksY.length + 4;\n  if (crossPeaksX.length > 0) {\n    for (let i = crossPeaksX.length - 1; i >= 0; i--) {\n      output[crossPeaksX[i]].x.delta = shift;\n    }\n  }\n  if (crossPeaksY.length > 0) {\n    for (let i = crossPeaksY.length - 1; i >= 0; i--) {\n      output[crossPeaksY[i]].y.delta = shift;\n    }\n  }\n  signal.x.delta = shift;\n  signal.y.delta = shift;\n  return hits;\n}\n\nfunction exist(\n  output: NMRSignal2D[],\n  properties: number[][],\n  signal: NMRSignal2D,\n  type: number,\n  symmetricSearch: boolean,\n) {\n  for (let i = output.length - 1; i >= 0; i--) {\n    if (properties[i][0] === type) {\n      if (distanceTo(signal, output[i], symmetricSearch) < tolerance) {\n        if (!symmetricSearch) {\n          let shiftX = (output[i].x.delta + signal.x.delta) / 2.0;\n          let shiftY = (output[i].y.delta + signal.y.delta) / 2.0;\n          output[i].x.delta = shiftX;\n          output[i].y.delta = shiftY;\n          signal.x.delta = shiftX;\n          signal.y.delta = shiftY;\n        } else {\n          let shiftX = signal.x.delta;\n          let shiftY = output[i].x.delta;\n          output[i].y.delta = shiftX;\n          signal.y.delta = shiftY;\n        }\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n/**\n * Try to determine the position of each signal within the spectrum matrix.\n * Peaks could be of 3 types: upper diagonal, diagonal or under diagonal 1,0,-1\n * respectively.\n * @param {Array} signals\n * @return {*} A matrix containing the properties of each signal\n * @private\n */\nfunction initializeProperties(signals: NMRSignal2D[]) {\n  let signalsProperties = new Array(signals.length);\n  for (let i = signals.length - 1; i >= 0; i--) {\n    signalsProperties[i] = [0, 0];\n    // We check if it is a diagonal peak\n    if (Math.abs(signals[i].x.delta - signals[i].y.delta) <= diagonalError) {\n      signalsProperties[i][1] = 1;\n      let shift = (signals[i].x.delta * 2 + signals[i].y.delta) / 3.0;\n      signals[i].x.delta = shift;\n      signals[i].y.delta = shift;\n    } else {\n      if (signals[i].x.delta - signals[i].y.delta > 0) {\n        signalsProperties[i][0] = 1;\n      } else {\n        signalsProperties[i][0] = -1;\n      }\n    }\n  }\n  return signalsProperties;\n}\n\n/**\n * This function calculates the distance between 2 nmr signals . If toImage is true,\n * it will interchange x by y in the distance calculation for the second signal.\n * @param {object} a\n * @param {object} b\n * @param {boolean} toImage\n * @return {number}\n * @private\n */\nfunction distanceTo(a: NMRSignal2D, b: NMRSignal2D, toImage: boolean) {\n  if (!toImage) {\n    return Math.sqrt(\n      Math.pow(a.x.delta - b.x.delta, 2) + Math.pow(a.y.delta - b.y.delta, 2),\n    );\n  } else {\n    return Math.sqrt(\n      Math.pow(a.x.delta - b.y.delta, 2) + Math.pow(a.y.delta - b.x.delta, 2),\n    );\n  }\n}\n\n// type Signal2DWithHighlight = MakeMandatory<NMRSignal2D, '_highlight'>;\n\n// function checkHighlight(signals2D: NMRSignal2D[]): asserts signals2D is Signal2DwithHighlight[] {\n//   for (let signal of signals2D) {\n//     if (!signal._highlight) throw new Error('there is not _hightlight property');\n//     if (!signal.nucleusX) throw new Error('there is not nucleusX property');\n//     if (!signal.nucleusY) throw new Error('there is not nucleusY property')\n//   }\n// }\n\n// function alignSingleDimension(signals2D: NMRSignal2D[], references) {\n//   // For each 2D signal\n//   for (let i = 0; i < signals2D.length; i++) {\n//     let signal2D = signals2D[i];\n//     for (let j = 0; j < references.length; j++) {\n//       const center = (references[j].startX + references[j].stopX) / 2;\n//       const width = Math.abs(references[j].startX - references[j].stopX) / 2;\n//       if (signal2D.nucleusX === references[j].nucleus) {\n//         // The 2D peak overlaps with the 1D signal\n//         if (Math.abs(signal2D.x.delta - center) <= width) {\n//           signal2D._highlight.push(references[j]._highlight[0]);\n//         }\n//       }\n//       if (signal2D.nucleusY === references[j].nucleus) {\n//         if (Math.abs(signal2D.y.delta - center) <= width) {\n//           signal2D._highlight.push(references[j]._highlight[0]);\n//         }\n//       }\n//     }\n//   }\n// }\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictAll.ts",["419"],"import type { Molecule } from 'openchemlib';\n\nimport type { Prediction1D } from '../types/prediction1D';\n\nimport { predictCOSY } from './predictCOSY';\nimport { predictCarbon, PredictCarbonOptions } from './predictCarbon';\nimport { predictHMBC } from './predictHMBC';\nimport { predictHSQC } from './predictHSQC';\nimport { predictProton, PredictProtonOptions } from './predictProton';\nimport { getPredictions } from './utils/getPredictions';\nimport type { Predictor } from './utils/predict2D';\n\n\nexport interface PredictAllOptions {\n  /**\n   * nucleus label to use in the X axis\n   * @default 'H'\n   */\n  from?: 'H' | 'C';\n  /**\n   * nucleus label to use in the Y axis\n   * @default 'C';\n   */\n  to?: 'H' | 'C';\n  /**\n   * maximum number of bonds to take into account.\n   * @default 1\n   */\n  maxLength?: number;\n  /**\n   * minimum number of bonds to take into account\n   * @default 1\n   */\n  minLength?: number;\n  /**\n   * mono dimensional predictors. The object should has properties with name\n   * equal to \"H\" and \"C\".\n   */\n  predictor?: { H?: Predictor; C?: Predictor };\n  /**\n   *  mono dimensional signal to generate the bidimenionals cross peaks.\n   * The object should has properties with name equal to \"H\" and \"C\".\n   */\n  predictOptions?: { H?: PredictProtonOptions; C?: PredictCarbonOptions };\n  /**\n   * signals with euclidean distance in ppm less than this it will\n   * joined into a zone.\n   * @default {H:0.05,C:0.5}\n   */\n  joinDistance?: { H: number; C: number };\n  /**\n   * mono dimensional signal to generate the bidimenionals cross peaks.\n   * The object should has properties with name equal to \"H\" and \"C\".\n   * the value of each prediction should be similar that predictProton and predictCarbon.\n   */\n  predictions?: {\n    [key: string]: Prediction1D | undefined;\n    H?: Prediction1D;\n    C?: Prediction1D;\n  };\n}\n/**\n * Generate the correlation bidimensional nmr peaks based on the number of bonds between a pair of atoms\n * @returns {Promise<object>} - object with molfile, diaIDs, 1D and 2D signals, joined signals, ranges and zones.\n */\n\nexport async function predictAll(\n  molecule: Molecule,\n  options: PredictAllOptions = {},\n) {\n  let {\n    from = 'H',\n    to = 'C',\n    predictor = { H: predictProton, C: predictCarbon },\n    predictions,\n    joinDistance = { H: 0.05, C: 0.5 },\n    predictOptions = {},\n  } = options;\n\n  const xPrediction = await getPredictions(\n    from,\n    molecule,\n    predictOptions,\n    predictor,\n    predictions,\n  );\n\n  const yPrediction = await getPredictions(\n    to,\n    molecule,\n    predictOptions,\n    predictor,\n    predictions,\n  );\n\n  if (!xPrediction || !yPrediction)\n    {throw new Error('predictions are not availaible');}\n\n  predictions = {\n    H: xPrediction,\n    C: yPrediction\n  }\n\n  const { molfile, diaIDs } = xPrediction;\n\n  const spectra: any = {\n    proton: predictions.H,\n    carbon: predictions.C,\n  };\n\n  spectra.cosy = await predictCOSY(molecule, {\n    predictions,\n    joinDistance,\n  });\n  spectra.hsqc = await predictHSQC(molecule, {\n    predictions,\n    joinDistance,\n  });\n  spectra.hmbc = await predictHMBC(molecule, {\n    predictions,\n    joinDistance,\n  });\n\n  for (const key in spectra) {\n    delete spectra[key].molfile;\n    delete spectra[key].diaIDs;\n  }\n\n  return {\n    molfile,\n    diaIDs,\n    ...spectra,\n  };\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictCarbon.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictCOSY.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictHMBC.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictHSQC.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\predictProton.ts",["420"],"import fetch from 'cross-fetch';\nimport FormData from 'form-data';\nimport type { Molecule } from 'openchemlib';\nimport {\n  addDiastereotopicMissingChirality,\n  getConnectivityMatrix,\n  getDiastereotopicAtomIDs,\n} from 'openchemlib-utils';\n\nimport { signalsJoin } from '../signals/signalsJoin';\nimport { signalsToRanges } from '../signals/signalsToRanges';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\nimport type { Prediction1D } from '../types/prediction1D';\n\n/**\n * Makes a prediction using proton.\n * @returns {Promise<object>} - object with molfile, diaIDs, signals, joined signals by diaIDs and ranges.\n */\n\nexport interface PredictProtonOptions {\n  /**\n   * A callback receiving a molfile and the result\n   */\n  cache?: (molfile: string, result?: string) => void | string | undefined;\n}\n\nexport type PredictProton = typeof predictProton;\n\nexport async function predictProton(\n  molecule: Molecule,\n  options: PredictProtonOptions = {},\n): Promise<Prediction1D> {\n  const { cache } = options;\n  molecule = molecule.getCompactCopy();\n  molecule.addImplicitHydrogens();\n  addDiastereotopicMissingChirality(molecule);\n  const molfile = molecule.toMolfile();\n\n  let result;\n  if (cache) {\n    result = cache(molfile);\n  }\n  if (result === undefined) {\n    const formData = new FormData();\n    formData.append('molfile', molfile);\n    const response = await fetch('https://www.nmrdb.org/service/predictor', {\n      method: 'POST',\n      //@ts-expect-error\n      body: formData,\n    });\n    result = await response.text();\n    if (cache) {\n      cache(molfile, result);\n    }\n  }\n\n  const diaIDs = getDiastereotopicAtomIDs(molecule);\n  const signals = protonParser(result, molecule, diaIDs);\n  const joinedSignals = signalsJoin(signals);\n  return {\n    molfile,\n    diaIDs,\n    nucleus: '1H',\n    joinedSignals,\n    signals,\n    ranges: signalsToRanges(joinedSignals),\n    molecule,\n  };\n}\n\nfunction protonParser(\n  result: string,\n  molecule: Molecule,\n  diaIDs: string[],\n): NMRSignal1D[] {\n  if (molecule.getAllAtoms() === 0) return [];\n  if (result.includes('ERR')) {\n    throw Error(`Spinus optimization: ${result}`);\n  }\n  let distanceMatrix = getConnectivityMatrix(molecule, { pathLength: true });\n  let lines = result.split('\\n').filter((line) => line);\n  let signals = [];\n  for (let line of lines) {\n    let fields: string[] = line.split('\\t');\n    let couplings = fields.slice(4);\n    let atom = Number(fields[0]) - 1;\n    let signal: NMRSignal1D = {\n      atoms: [atom],\n      diaIDs: [diaIDs[atom]],\n      nbAtoms: 1,\n      delta: Number(fields[2]),\n      js: [],\n    };\n\n    if (!signal.js) {\n      throw new Error(`For atom js property was not added`);\n    }\n    for (let i = 0; i < couplings.length; i += 3) {\n      let linked = Number(couplings[i]) - 1;\n      signal.js.push({\n        coupling: Number(couplings[i + 2]),\n        atoms: [linked],\n        diaIDs: [diaIDs[linked]],\n        multiplicity: 'd',\n        distance: distanceMatrix[atom][linked],\n      });\n      signal.js.sort((a, b) => b.coupling - a.coupling);\n    }\n    signals.push(signal);\n  }\n  return signals;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\fetchPrediction.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\flatGroupedDiaIDs.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getFilteredIDiaIDs.ts",["421"],"import type { Molecule } from 'openchemlib';\nimport {\n  getGroupedDiastereotopicAtomIDs,\n  getHoseCodesFromDiastereotopicID,\n  addDiastereotopicMissingChirality,\n} from 'openchemlib-utils';\nimport type { GroupDiastereotopicAtomIDs } from 'openchemlib-utils';\n\nexport interface GroupDiaIDsWithHose extends GroupDiastereotopicAtomIDs {\n  hose: string[];\n}\n\nexport type GroupedDiaIDsWithHose = GroupDiaIDsWithHose[];\n\nexport function getFilteredIDiaIDs(\n  molecule: Molecule,\n  options: { maxSphereSize: number },\n) {\n  const { maxSphereSize } = options;\n\n  molecule.addImplicitHydrogens();\n  molecule.addMissingChirality();\n  addDiastereotopicMissingChirality(molecule);\n\n  const molfile = molecule.toMolfile();\n\n  let groupedDiaIDs =\n    getGroupedDiastereotopicAtomIDs(molecule);\n\n  let carbonDiaIDs = groupedDiaIDs\n    .filter((e) => e.atomLabel === 'C')\n    .sort((a, b) => {\n      if (a.atomLabel === b.atomLabel) {\n        return b.counter - a.counter;\n      }\n      return a.atomLabel < b.atomLabel ? 1 : -1;\n    }) as any;\n\n  const OCL = molecule.getOCL();\n  for (const diaId of carbonDiaIDs) {\n    diaId.hose = getHoseCodesFromDiastereotopicID(\n      OCL.Molecule.fromIDCode(diaId.oclID),\n      {\n        maxSphereSize,\n      },\n    );\n  }\n\n  let toReturn = {\n    molfile,\n    carbonDiaIDs: carbonDiaIDs as GroupedDiaIDsWithHose,\n    groupedDiaIDs,\n  };\n\n  return toReturn;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getPredictions.ts",["422"],"import type { Molecule } from \"openchemlib\";\n\nimport type { Prediction1D } from \"../../types/prediction1D\";\n\nimport type { Predictions, PredictOptions, Predictors } from './predict2D';\n\nexport async function getPredictions(\n  key: string,\n  molecule: Molecule,\n  predictOptions: PredictOptions,\n  predictor?: Predictors,\n  predictions?: Predictions,\n) {\n  let prediction: Prediction1D | undefined;\n  if (predictions && predictions[key]) {\n    prediction = predictions[key];\n  } else if (predictor) {\n    const fromPredictor = predictor[key];\n    prediction = fromPredictor\n      ? await fromPredictor(molecule, predictOptions[key])\n      : undefined;\n  }\n  return prediction;\n}","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\predict2D.ts",["423","424","425","426"],"import { agnes, Cluster } from 'ml-hclust';\nimport { Matrix } from 'ml-matrix';\nimport { Molecule } from 'openchemlib';\nimport {\n  getGroupedDiastereotopicAtomIDs,\n  getPathsInfo,\n} from 'openchemlib-utils';\nimport type {\n  AtomInfo,\n  GroupDiastereotopicAtomIDs,\n  PathInfo,\n} from 'openchemlib-utils';\n\nimport type { MakeMandatory } from '../../types/MakeMandatory';\nimport type { NMRSignal1D } from '../../types/NMRSignal1D';\nimport type { NMRSignal2D } from '../../types/NMRSignal2D';\nimport type { Prediction1D } from '../../types/prediction1D';\nimport type { PredictCarbon, PredictCarbonOptions } from '../predictCarbon';\nimport type { PredictProton, PredictProtonOptions } from '../predictProton';\n\nimport { getNuclei } from './getNuclei';\nimport { getPredictions } from './getPredictions';\n\n/**\n * Generate the correlation bidimensional nmr peaks based on the number of bonds between a pair of atoms\n * @returns {object} - object with molfile, diaIDs, 2D signals and zones.\n */\n\nexport type Predictor = PredictCarbon | PredictProton;\n\nexport interface Predictors {\n  [key: string]: Predictor | undefined;\n  H?: Predictor;\n  C?: Predictor;\n}\n\ninterface JoinDistanceOption {\n  [key: string]: number;\n  H: number;\n  C: number;\n}\n\nexport interface Predict2DOptions {\n  /**\n   * nucleus label to use in the X axis\n   */\n  from?: 'H' | 'C';\n  /**\n   * nucleus label to use in the Y axis\n   */\n  to?: 'H' | 'C';\n  /**\n   * maximum number of bonds to take into account.\n   */\n  maxLength?: number;\n  /**\n   * minimum number of bonds to take into account\n   * @default 0\n   */\n  minLength?: number;\n  /**\n   * mono dimensional predictors.\n   */\n  predictor?: Predictors;\n  /**\n   *  mono dimensional signal to generate the bidimenionals cross peaks.\n   * The object should has properties with name equal to \"H\" and \"C\".\n   */\n  predictOptions?: PredictOptions;\n  /**\n   * signals with euclidean distance in ppm less than this it will\n   * joined into a zone.\n   * @default {H:0.05,C:0.5}\n   */\n  joinDistance?: JoinDistanceOption;\n  /**\n   * mono dimensional signal to generate the bidimenionals cross peaks.\n   * The object should has properties with name equal to \"H\" and \"C\".\n   * the value of each prediction should be similar that predictProton and predictCarbon.\n   */\n  predictions?: Predictions;\n  /**\n   * if true, the self correlation signal will be add to the prediction.\n   * @default false\n   */\n  includeDiagonal?: boolean;\n}\n\nexport interface PredictOptions {\n  [key: string]: PredictProtonOptions | PredictCarbonOptions | undefined;\n  H?: PredictProtonOptions;\n  C?: PredictCarbonOptions;\n}\n\nexport interface Predictions {\n  [key: string]: Prediction1D | undefined;\n  H?: Prediction1D;\n  C?: Prediction1D;\n}\n\ntype GroupDiastereotopicAtomIDsWithAtomInfo = GroupDiastereotopicAtomIDs & {\n  atomInfo: PathInfo;\n};\n\ntype PredictHMBCOptionsWithFromTo = MakeMandatory<\n  Predict2DOptions,\n  'from' | 'to'\n>;\n\nfunction checkFromTo(\n  options: Predict2DOptions,\n): asserts options is PredictHMBCOptionsWithFromTo {\n  if (!options.from || !options.to) {\n    throw new Error('options from and to are mandatory');\n  }\n}\n\ninterface Signal1DByDiaID {\n  [key: string]: { [key: string]: NMRSignal1D };\n}\n\nexport async function predict2D(\n  molecule: Molecule,\n  options: Predict2DOptions = {},\n) {\n  checkFromTo(options);\n\n  let {\n    from,\n    to,\n    minLength = 0,\n    maxLength,\n    predictOptions = {},\n    predictions,\n    predictor,\n    joinDistance = { H: 0.05, C: 0.5 },\n    includeDiagonal = false,\n  } = options;\n\n  molecule.addImplicitHydrogens();\n\n  let diaIDs = getGroupedDiastereotopicAtomIDs(molecule);\n\n  const paths = getPathsInfo(molecule, {\n    fromLabel: from,\n    toLabel: to,\n    minLength,\n    maxLength,\n  });\n\n  let diaIDswithAtomInfo: GroupDiastereotopicAtomIDsWithAtomInfo[] = [];\n  for (let diaID of diaIDs) {\n    diaIDswithAtomInfo.push({\n      ...diaID,\n      atomInfo: JSON.parse(JSON.stringify(paths[diaID.atoms[0]])) as PathInfo,\n    });\n  }\n\n  const xPrediction = await getPredictions(\n    from,\n    molecule,\n    predictOptions,\n    predictor,\n    predictions,\n  );\n\n  const yPrediction =\n    from === to\n      ? xPrediction\n      : await getPredictions(\n          to,\n          molecule,\n          predictOptions,\n          predictor,\n          predictions,\n        );\n\n  if (!xPrediction || !yPrediction) {\n    throw new Error('predictions are not availaible');\n  }\n\n  const spectra: { [key: string]: Prediction1D } = {\n    x: xPrediction,\n    y: yPrediction,\n  };\n\n  const signalsByDiaID: Signal1DByDiaID = {\n    x: {},\n    y: {},\n  };\n  for (const axis in signalsByDiaID) {\n    for (const signal of spectra[axis].joinedSignals) {\n      if (!signal.diaIDs) throw new Error('Signal has not diaIDs');\n      signalsByDiaID[axis][signal.diaIDs[0]] = signal;\n    }\n  }\n\n  let group: { [key: string]: NMRSignal2D } = {};\n  for (const diaID of diaIDswithAtomInfo) {\n    const atom = diaID.atomInfo;\n    if (atom.paths.length < 1) continue;\n\n    if (!signalsByDiaID.x[atom.oclID]) continue;\n\n    const currentPaths = atom.paths;\n    for (const path of currentPaths) {\n      if (!signalsByDiaID.y[paths[path.to].oclID]) continue;\n\n      let fromToDiaID: { [key: string]: AtomInfo } = {\n        x: atom,\n        y: paths[path.to],\n      };\n\n      const key = `${fromToDiaID.x.oclID}-${fromToDiaID.y.oclID}`;\n\n      if (key === `${atom.oclID}-${atom.oclID}` || group[key]) {\n        continue;\n      }\n\n      let peak: any = { z: 100 };\n      let signal: any = { x: {}, y: {} };\n      for (let axis in fromToDiaID) {\n        let diaID = fromToDiaID[axis].oclID;\n        peak[axis] = signalsByDiaID[axis][diaID].delta;\n        signal[axis].delta = signalsByDiaID[axis][diaID].delta;\n        signal[axis].diaIDs = [diaID];\n        signal[axis].atoms = signalsByDiaID[axis][diaID].atoms;\n      }\n\n      signal.peaks = [peak];\n\n      group[key] = signal as NMRSignal2D;\n    }\n  }\n\n  if (includeDiagonal) addSelftCorrelation(group, { paths, signalsByDiaID });\n\n  // clusterize signals by distance\n  const joinedSignals = Object.values(group);\n  const zones = createZones(joinedSignals, { joinDistance, from, to });\n\n  return {\n    molfile: molecule.toMolfile(),\n    diaIDs: spectra.x.diaIDs,\n    nuclei: getNuclei({ from, to }),\n    joinedSignals,\n    signals: splitSignals(joinedSignals),\n    zones,\n    molecule,\n  };\n}\n\nfunction splitSignals(joinedSignals: NMRSignal2D[]) {\n  let signals = [];\n  for (const signal of joinedSignals) {\n    for (const xAtom of signal.x.atoms || []) {\n      for (const yAtom of signal.y.atoms || []) {\n        let newSignal = JSON.parse(JSON.stringify(signal));\n        newSignal.x.atoms = [xAtom];\n        newSignal.y.atoms = [yAtom];\n        signals.push(newSignal);\n      }\n    }\n  }\n  return signals;\n}\n\ninterface AddSelftCorrelationOptions {\n  paths: PathInfo[];\n  signalsByDiaID: Signal1DByDiaID;\n}\nfunction addSelftCorrelation(\n  group: { [key: string]: NMRSignal2D },\n  options: AddSelftCorrelationOptions,\n) {\n  const { paths = [], signalsByDiaID } = options;\n  for (const atom of paths) {\n    if (atom.paths.length < 1) continue;\n\n    let diaID = atom.oclID;\n    if (!signalsByDiaID.x[diaID]) continue;\n    if (group[`${diaID}-${diaID}`]) continue;\n\n    let signal: any = { x: {}, y: {} };\n\n    let peak: any = { z: 1 };\n    for (let axis of ['x', 'y']) {\n      peak[axis] = signalsByDiaID[axis][diaID].delta;\n      signal[axis].delta = signalsByDiaID[axis][diaID].delta;\n      signal[axis].diaIDs = [diaID];\n      signal[axis].atoms = signalsByDiaID[axis][diaID].atoms;\n    }\n\n    signal.peaks = [peak];\n\n    group[`${atom.oclID}-${atom.oclID}`] = signal as NMRSignal2D;\n  }\n}\n\ninterface CreateZonesOptions {\n  joinDistance: JoinDistanceOption;\n  from: string;\n  to: string;\n}\nfunction createZones(signals: NMRSignal2D[], options: CreateZonesOptions) {\n  const { joinDistance, from, to } = options;\n  const deltas = new Matrix(signals.map((e) => [e.x.delta, e.y.delta]));\n\n  const minX = deltas.minColumn(0);\n  const maxX = deltas.maxColumn(0);\n  const minY = deltas.minColumn(1);\n  const maxY = deltas.maxColumn(1);\n\n  deltas.mulColumn(0, 1 / (maxX - minX));\n  deltas.mulColumn(1, 1 / (maxY - minY));\n\n  const cutOff = Math.sqrt(\n    Math.pow(joinDistance[from] / (maxX - minX), 2) +\n      Math.pow(joinDistance[to] / (maxY - minY), 2),\n  );\n\n  let hClusters = agnes(deltas.to2DArray(), { method: 'centroid' });\n  const clusters = splitClusters([hClusters], cutOff);\n\n  const zones = [];\n  for (const cluster of clusters) {\n    const signal = [];\n    if (cluster.isLeaf) signal.push(signals[cluster.index]);\n    for (const child of cluster.children) {\n      for (const index of child.indices()) {\n        signal.push(signals[index]);\n      }\n    }\n\n    zones.push({\n      ...fromTo(signal, { joinDistance, from, to }),\n      signals: signal,\n    });\n  }\n  return zones;\n}\n\nfunction fromTo(signals: NMRSignal2D[], options: CreateZonesOptions) {\n  const { joinDistance, from, to } = options;\n  let minX = Number.MAX_SAFE_INTEGER;\n  let minY = Number.MAX_SAFE_INTEGER;\n  let maxX = Number.MIN_SAFE_INTEGER;\n  let maxY = Number.MIN_SAFE_INTEGER;\n  for (const signal of signals) {\n    if (signal.x.delta < minX) minX = signal.x.delta;\n    if (signal.x.delta > maxX) maxX = signal.x.delta;\n    if (signal.y.delta < minY) minY = signal.y.delta;\n    if (signal.y.delta > maxY) maxY = signal.y.delta;\n  }\n  return {\n    x: { from: minX - joinDistance[from], to: maxX + joinDistance[from] },\n    y: { from: minY - joinDistance[to], to: maxY + joinDistance[to] },\n  };\n}\n\nfunction splitClusters(clusters: Cluster[], maxDistance: number): Cluster[] {\n  let originalLength = clusters.length;\n  for (let i = 0; i < clusters.length; i++) {\n    const cluster = clusters[i];\n    if (cluster.height > maxDistance) {\n      clusters.push(...cluster.children);\n      clusters.splice(i--, 1);\n    }\n  }\n  return clusters.length < originalLength\n    ? splitClusters(clusters, maxDistance)\n    : clusters;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\queryByHOSE.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictAll.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictCarbon.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictCOSY.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictHMBC.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictHSQC.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\__tests__\\predictProton.test.ts",["427"],"import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\n\n//@ts-expect-error\nimport md5 from 'md5';\nimport OCL from 'openchemlib/minimal';\n\nimport type { MakeMandatory } from '../../types/MakeMandatory';\nimport type { NMRRange } from '../../types/NMRRange';\nimport type { NMRSignal1D } from '../../types/NMRSignal1D';\nimport { predictProton } from '../predictProton';\n\nconst molfile = `Benzene, ethyl-, ID: C100414\n  NIST    16081116462D 1   1.00000     0.00000\nCopyright by the U.S. Sec. Commerce on behalf of U.S.A. All rights reserved.\n  8  8  0     0  0              1 V2000\n    0.5015    0.0000    0.0000 C   0  0  0  0  0  0           0  0  0\n    0.0000    0.8526    0.0000 C   0  0  0  0  0  0           0  0  0\n    1.5046    0.0000    0.0000 C   0  0  0  0  0  0           0  0  0\n    2.0062    0.8526    0.0000 C   0  0  0  0  0  0           0  0  0\n    3.0092    0.8526    0.0000 C   0  0  0  0  0  0           0  0  0\n    1.5046    1.7554    0.0000 C   0  0  0  0  0  0           0  0  0\n    0.5015    1.7052    0.0000 C   0  0  0  0  0  0           0  0  0\n    3.5108    0.0000    0.0000 C   0  0  0  0  0  0           0  0  0\n  1  2  2  0     0  0\n  3  1  1  0     0  0\n  2  7  1  0     0  0\n  4  3  2  0     0  0\n  4  5  1  0     0  0\n  6  4  1  0     0  0\n  5  8  1  0     0  0\n  7  6  2  0     0  0\nM  END\n`;\n\nconst cache = (molfile: string, value: any) => {\n  const hash = md5(molfile);\n  const cacheDir = join(__dirname, 'cache');\n  const cacheFilename = join(cacheDir, hash);\n  if (!existsSync(cacheDir)) mkdirSync(cacheDir);\n  if (value === undefined) {\n    if (existsSync(cacheFilename)) {\n      return readFileSync(cacheFilename, 'utf8');\n    } else {\n      return;\n    }\n  } else {\n    writeFileSync(cacheFilename, value, 'utf8');\n  }\n};\n\ntype Signal1DWithJs = MakeMandatory<NMRSignal1D, 'js'>;\ntype RangeWithSignals = Omit<NMRRange, 'signals'> & {\n  signals: Signal1DWithJs[];\n};\nfunction checkRange(range: NMRRange): asserts range is RangeWithSignals {\n  if (!range.signals) throw new Error('There is not signals in range');\n  for (const signal of range.signals) {\n    if (!signal.js) throw new Error('There is not js in signal');\n  }\n}\ndescribe('predictProton', () => {\n  it('1H chemical shift prediction', async () => {\n    const molecule = OCL.Molecule.fromMolfile(molfile);\n    const prediction = await predictProton(molecule, { cache });\n    expect(Object.keys(prediction)).toStrictEqual([\n      'molfile',\n      'diaIDs',\n      'nucleus',\n      'joinedSignals',\n      'signals',\n      'ranges',\n      'molecule',\n    ]);\n    let firstSignal = prediction.signals[0];\n\n    expect(firstSignal).toStrictEqual({\n      atoms: [8],\n      diaIDs: ['did@`@f\\\\bbRaih@J@A~dHBIU@'],\n      nbAtoms: 1,\n      delta: 7.26,\n      js: [\n        {\n          coupling: 7.758,\n          atoms: [10],\n          diaIDs: ['did@`@fTfYUn`HH@GzP`HeT'],\n          multiplicity: 'd',\n          distance: 3,\n        },\n        {\n          coupling: 7.718,\n          atoms: [9],\n          diaIDs: ['did@`@fTfUvf`@h@GzP`HeT'],\n          multiplicity: 'd',\n          distance: 3,\n        },\n        {\n          coupling: 1.596,\n          atoms: [14],\n          diaIDs: ['did@`@f\\\\bbRaih@J@A~dHBIU@'],\n          multiplicity: 'd',\n          distance: 4,\n        },\n        {\n          coupling: 0.507,\n          atoms: [13],\n          diaIDs: ['did@`@fTfYUn`HH@GzP`HeT'],\n          multiplicity: 'd',\n          distance: 5,\n        },\n      ],\n    });\n    let firstJoinedSignal = prediction.joinedSignals[0];\n    expect(firstJoinedSignal).toStrictEqual({\n      nbAtoms: 3,\n      delta: 0.992,\n      multiplicity: 't',\n      diaIDs: ['did@`@fTeYWaj@@@GzP`HeT'],\n      atoms: [15, 16, 17],\n      js: [\n        {\n          coupling: 7.392,\n          multiplicity: 't',\n          diaIDs: ['did@`@fTf[Waj@@bJ@_iB@bUP'],\n          distance: 3,\n        },\n      ],\n    });\n    expect(prediction.ranges).toHaveLength(3);\n    let lastRange = prediction.ranges[2];\n    checkRange(lastRange);\n    expect(lastRange.integration).toBe(5);\n    expect(lastRange.signals).toHaveLength(3);\n    expect(lastRange.signals[0].js).toHaveLength(4);\n  }, 30000);\n  it('empty molecule', async () => {\n    const molecule = new OCL.Molecule(16, 16);\n    const result = await predictProton(molecule);\n    expect(result.diaIDs).toStrictEqual([]);\n    expect(result.joinedSignals).toStrictEqual([]);\n    expect(result.signals).toStrictEqual([]);\n    expect(result.ranges).toStrictEqual([]);\n    expect(result.molecule.getAllAtoms()).toBe(0);\n    expect(result.molecule.getAllBonds()).toBe(0);\n  }, 30000);\n});\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\rangesToACS.ts",["428","429","430","431","432","433","434","435","436","437"],"import { signalJoinCouplings } from '../signal/signalJoinCouplings';\nimport { signalMultiplicityPattern } from '../signal/signalMultiplicityPattern';\nimport type { NMRRange } from '../types/NMRRange';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\n\nconst globalOptions = {\n  h: {\n    nucleus: '1H',\n    nbDecimalDelta: 2,\n    nbDecimalJ: 1,\n    observedFrequency: 400,\n  },\n  c: {\n    nucleus: '13C',\n    nbDecimalDelta: 1,\n    nbDecimalJ: 1,\n    observedFrequency: 100,\n  },\n  f: {\n    nucleus: '19F',\n    nbDecimalDelta: 2,\n    nbDecimalJ: 1,\n    observedFrequency: 400,\n  },\n};\n\nexport interface RangesToACSOptions {\n  /**\n   * nucleus\n   * @default '1H'\n   */\n  nucleus?: string;\n  ascending?: boolean;\n  format?: string;\n  /**\n   * default value depends of nucleus\n   * @default 1|2\n   */\n  nbDecimalDelta?: number;\n  /**\n   * Number of decimals to round the scalar coupling value\n   * @default 1\n   */\n  nbDecimalJ?: number;\n  /**\n   * default value depends of nucleus\n   * @default 400|100\n   */\n  observedFrequency?: number;\n  /**\n   * @default true\n   */\n  filter?: boolean;\n  /**\n   * solvent name\n   */\n  solvent?: string;\n}\n\nexport function rangesToACS(\n  ranges: NMRRange[],\n  options: RangesToACSOptions = {},\n) {\n  if (!options.nucleus) options.nucleus = '1H';\n  let nucleus = options.nucleus.toLowerCase().replace(/[0-9]/g, '');\n  //@ts-expect-error\n  let defaultOptions = globalOptions[nucleus];\n  options = Object.assign(\n    {},\n    defaultOptions,\n    { ascending: false, format: 'IMJA' },\n    options,\n  );\n\n  ranges = JSON.parse(JSON.stringify(ranges));\n  if (options.ascending === true) {\n    ranges.sort((a, b) => {\n      let fromA = Math.min(a.from, a.to);\n      let fromB = Math.min(b.from, b.to);\n      return fromA - fromB;\n    });\n  }\n  let acsString = formatAcs(ranges, options);\n\n  if (acsString.length > 0) acsString += '.';\n\n  return acsString;\n}\n\nfunction formatAcs(ranges: NMRRange[], options: any) {\n  let acs = spectroInformation(options);\n  if (acs.length === 0) acs = ' ';\n  let acsRanges: string[] = [];\n  for (let range of ranges) {\n    if (uselessKind(range.kind, options.filter)) continue;\n    pushDelta(range, acsRanges, options);\n  }\n  if (acsRanges.length > 0) {\n    return acs + acsRanges.join(', ');\n  } else {\n    return '';\n  }\n}\n\nfunction spectroInformation(options: any) {\n  let parenthesis = [];\n  let strings = `${formatNucleus(options.nucleus)} NMR`;\n  if (options.solvent) {\n    parenthesis.push(formatMF(options.solvent));\n  }\n  if (options.observedFrequency) {\n    parenthesis.push(`${(options.observedFrequency * 1).toFixed(0)} MHz`);\n  }\n  if (parenthesis.length > 0) {\n    strings += ` (${parenthesis.join(', ')}):  `;\n  } else {\n    strings += ':  ';\n  }\n  return strings;\n}\n\nfunction pushDelta(range: NMRRange, acsRanges: string[], options: any) {\n  let strings = '';\n  let parenthesis: any = [];\n  let fromTo = [range.from, range.to];\n\n  if (range.signals) {\n    range.signals = range.signals.filter(\n      (signal) => !uselessKind(signal.kind, options.filter),\n    );\n  }\n\n  if (range.signals && range.signals.length > 0) {\n    let signals = range.signals;\n    if (signals.length > 1) {\n      if (options.ascending === true) {\n        signals.sort((a, b) => {\n          return a.delta - b.delta;\n        });\n      }\n      strings += `${Math.min(...fromTo).toFixed(\n        options.nbDecimalDelta,\n      )}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;\n      strings += ` (${getIntegral(range, options)}`;\n      for (let signal of signals) {\n        parenthesis = [];\n        if (signal.delta !== undefined) {\n          strings = appendSeparator(strings);\n          strings += signal.delta.toFixed(options.nbDecimalDelta);\n        }\n        const range: NMRRange = {\n          from: Number.MIN_SAFE_INTEGER,\n          to: Number.MAX_SAFE_INTEGER,\n        };\n        switchFormat(range, signal, parenthesis, options);\n        if (parenthesis.length > 0) strings += ` (${parenthesis.join(', ')})`;\n      }\n      strings += ')';\n    } else {\n      parenthesis = [];\n      if (signals[0].delta !== undefined) {\n        strings += signals[0].delta.toFixed(options.nbDecimalDelta);\n        switchFormat(range, signals[0], parenthesis, options);\n        if (parenthesis.length > 0) strings += ` (${parenthesis.join(', ')})`;\n      } else {\n        strings += `${Math.min(...fromTo).toFixed(\n          options.nbDecimalDelta,\n        )}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;\n        switchFormat(range, signals[0], parenthesis, options);\n        if (parenthesis.length > 0) strings += ` (${parenthesis})`;\n      }\n    }\n  } else {\n    strings += `${Math.min(...fromTo).toFixed(\n      options.nbDecimalDelta,\n    )}-${Math.max(...fromTo).toFixed(options.nbDecimalDelta)}`;\n    const signal: any = {};\n    switchFormat(range, signal, parenthesis, options);\n    if (parenthesis.length > 0) strings += ` (${parenthesis.join(', ')})`;\n  }\n  acsRanges.push(strings);\n}\n\nfunction getIntegral(range: NMRRange, options: any) {\n  let integration = '';\n  if (range.pubIntegral) {\n    integration = String(range.pubIntegral);\n  } else if (range.integration) {\n    integration =\n      range.integration.toFixed(0) +\n      options.nucleus[options.nucleus.length - 1];\n  }\n  return integration;\n}\n\nfunction pushIntegral(range: NMRRange, parenthesis: string[], options: any) {\n  let integration = getIntegral(range, options);\n  if (integration.length > 0) parenthesis.push(integration);\n}\n\nfunction pushmultiplicityFromSignal(\n  signal: NMRSignal1D,\n  parenthesis: string[],\n) {\n  let multiplicity = signal.multiplicity;\n  if (!multiplicity) {\n    let joinedCouplings = signalJoinCouplings(signal, {\n      tolerance: 0.05,\n      ignoreDiaIDs: true,\n    });\n    multiplicity = signalMultiplicityPattern(joinedCouplings);\n  }\n  if (multiplicity.length > 0) parenthesis.push(multiplicity);\n}\n\nfunction switchFormat(\n  range: NMRRange,\n  signal: NMRSignal1D,\n  parenthesis: string[],\n  options: any,\n) {\n  for (const char of options.format) {\n    switch (char.toUpperCase()) {\n      case 'I':\n        pushIntegral(range, parenthesis, options);\n        break;\n      case 'M':\n        pushmultiplicityFromSignal(signal, parenthesis);\n        break;\n      case 'A':\n        pushAssignment(signal, parenthesis);\n        break;\n      case 'J':\n        pushCoupling(signal, parenthesis, options);\n        break;\n      default:\n        throw new Error(`Unknow format letter: ${char}`);\n    }\n  }\n}\n\nfunction formatMF(mf: string) {\n  return mf.replace(/(?<num>[0-9]+)/g, '<sub>$<num></sub>');\n}\n\nfunction formatNucleus(nucleus: string) {\n  return nucleus.replace(/(?<num>[0-9]+)/g, '<sup>$<num></sup>');\n}\n\nfunction appendSeparator(strings: string) {\n  if (strings.length > 0 && !/ $/.exec(strings) && !/\\($/.exec(strings)) {\n    strings += ', ';\n  }\n  return strings;\n}\n\nfunction formatAssignment(assignment: string) {\n  assignment = assignment.replace(/(?<num>[0-9]+)/g, '<sub>$<num></sub>');\n  assignment = assignment.replace(/\"(?<i>[^\"]*)\"/g, '<i>$<i></i>');\n  return assignment;\n}\n\nfunction pushCoupling(\n  signal: NMRSignal1D,\n  parenthesis: string[],\n  options: any,\n) {\n  if (Array.isArray(signal.js) && signal.js.length > 0) {\n    signal.js.sort((a, b) => {\n      return b.coupling - a.coupling;\n    });\n\n    let values = [];\n    for (let j of signal.js) {\n      if (j.coupling !== undefined) {\n        values.push(j.coupling.toFixed(options.nbDecimalJ));\n      }\n    }\n    if (values.length > 0) {\n      parenthesis.push(`<i>J</i> = ${values.join(', ')} Hz`);\n    }\n  }\n}\n\nfunction pushAssignment(signal: NMRSignal1D, parenthesis: string[]) {\n  if (signal.assignment) {\n    parenthesis.push(formatAssignment(signal.assignment));\n  }\n}\n\nfunction uselessKind(kind = '', filter = true) {\n  kind = kind.toLowerCase();\n  if (filter && (kind === 'impurity' || kind === 'solvent')) return true;\n  return false;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\__tests__\\rangesToACS.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\signalJoinCouplings.ts",["438"],"import sum from 'ml-array-sum';\n\nimport type { MakeMandatory } from '../types/MakeMandatory';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\nimport type { Jcoupling } from '../types/jcoupling';\nimport { joinPatterns } from '../utilities/joinPatterns';\n\nexport interface SignalJoinCouplingsOptions {\n  /**\n   * tolerance to merge the couplings\n   * @default 0.05\n   */\n  tolerance?: number;\n  /**\n   * if it's true, the j coupling will be joined by proximity\n   * @default false\n   */\n  ignoreDiaIDs?: boolean;\n}\n\ntype JcouplingWithDiaID = MakeMandatory<Jcoupling, 'diaIDs'>;\ntype Signal1DWidthJs = MakeMandatory<NMRSignal1D, 'js'>;\ntype Signal1DWidthJsAndDiaID = Omit<Signal1DWidthJs, 'js'> & {\n  js: JcouplingWithDiaID[];\n};\n\nconst localeCompare = (a: string, b: string) => a.localeCompare(b);\nconst localeCompareJcouplingKeys = (\n  a: JcouplingWithDiaID,\n  b: JcouplingWithDiaID,\n) => {\n  const aa = `${a.diaIDs.sort(localeCompare).join(' ')}`;\n  const bb = `${b.diaIDs.sort(localeCompare).join(' ')}`;\n  return localeCompare(aa, bb);\n};\n\nconst areThanClose = (a: Jcoupling, b: Jcoupling, tolerance: number) =>\n  Math.abs(a.coupling - b.coupling) < tolerance;\n\nconst takeCareDiaIDs = (\n  a: JcouplingWithDiaID,\n  b: JcouplingWithDiaID,\n  tolerance: number,\n) => localeCompareJcouplingKeys(a, b) === 0 && areThanClose(a, b, tolerance);\n\n/**\n * Join couplings smaller than a define tolerance.\n * The resulting coupling should be an average of the existing one.\n * If distance is specified and is not always the same this property will be removed.\n */\nexport function signalJoinCouplings(\n  signal: NMRSignal1D,\n  options: SignalJoinCouplingsOptions = {},\n) {\n  const { tolerance = 0.05, ignoreDiaIDs = false } = options;\n\n  if (!signal.js || signal.js.length < 2) return signal;\n\n  if (ignoreDiaIDs) {\n    checkJs(signal);\n    return groupJCouplings(signal, areThanClose, tolerance);\n  } else {\n    checkJsAndDiaID(signal);\n    return groupJCouplings(signal, takeCareDiaIDs, tolerance);\n  }\n}\n\nfunction groupJCouplings(\n  signal: Signal1DWidthJs,\n  comparator: any,\n  tolerance: number,\n) {\n  signal.js.sort((a, b) => b.coupling - a.coupling);\n\n  let currentGroup = [signal.js[0]];\n  let groups = [currentGroup];\n  for (let i = 1; i < signal.js.length; i++) {\n    let currentJ = signal.js[i];\n    if (\n      comparator(currentGroup[currentGroup.length - 1], currentJ, tolerance)\n    ) {\n      currentGroup.push(currentJ);\n    } else {\n      currentGroup = [currentJ];\n      groups.push(currentGroup);\n    }\n  }\n\n  signal.js = [];\n  for (let group of groups) {\n    let coupling = sum(group.map((group) => group.coupling)) / group.length;\n    let atoms = distinctValues(\n      group\n        .filter((group) => group.atoms)\n        .map((group) => group.atoms)\n        .flat() as number[],\n    ) as number[];\n\n    let assignment = distinctValues(\n      group\n        .filter((group) => group.assignment)\n        .map((group) => group.assignment)\n        .flat() as string[],\n    ).join(' ');\n\n    let diaIDs = distinctValues(\n      group\n        .filter((group) => group.diaIDs)\n        .map((group) => group.diaIDs)\n        .flat() as string[],\n    ) as string[];\n\n    let distances = distinctValues(\n      group.map((group) => group.distance) as number[],\n    ) as number[];\n\n    let multiplicity = joinPatterns(\n      group\n        .filter((group) => group.multiplicity)\n        .map((group) => group.multiplicity) as string[],\n    );\n\n    let newJ: Jcoupling = {\n      coupling,\n      multiplicity,\n    };\n\n    if (diaIDs.length === 1) newJ.diaIDs = diaIDs;\n    if (distances.length === 1 && distances[0]) newJ.distance = distances[0];\n    if (assignment.length > 0) newJ.assignment = assignment;\n    if (atoms.length > 0) newJ.atoms = atoms;\n    signal.js.push(newJ);\n  }\n  return signal;\n}\n\nfunction distinctValues(array: string[] | number[]) {\n  const onlyDifferents = new Set();\n  for (const element of array) {\n    onlyDifferents.add(element);\n  }\n\n  return Array.from(onlyDifferents);\n}\n\nfunction checkJsAndDiaID(\n  signal: NMRSignal1D,\n): asserts signal is Signal1DWidthJsAndDiaID {\n  if (!signal.js) throw new Error('there is not js');\n  for (const jcoupling of signal.js) {\n    if (!jcoupling.diaIDs) throw new Error('there is not diaIDs');\n  }\n}\n\nfunction checkJs(signal: NMRSignal1D): asserts signal is Signal1DWidthJs {\n  if (!signal.js) throw new Error('there is not js');\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\signalMultiplicityPattern.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\__tests__\\signalJoinCouplings.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signal\\__tests__\\signalMultiplicityPattern.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\hackSignalsToXY.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signals2DToZ.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsJoin.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsToRanges.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\signalsToXY.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\getPauliMatrix.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\signalsToSpinSystem.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\simulate1D.ts",["439"],"import binarySearch from 'binary-search';\nimport { Matrix, EVD } from 'ml-matrix';\nimport type { Matrix as MatrixClassType } from 'ml-matrix';\nimport { SparseMatrix } from 'ml-sparse-matrix';\nimport { SpectrumGenerator } from 'spectrum-generator';\nimport type { Shape1DOption } from 'spectrum-generator';\n\nimport type { SpinSystem } from '../../types/spinSystem';\n\nimport getPauliMatrix from './getPauliMatrix';\n\nconst smallValue = 1e-2;\n\ninterface Simulate1DOptions {\n  /**\n   * The linewidth of the output spectrum, expresed in Hz.\n   * @default 1\n   */\n  lineWidth?: number;\n  /**\n   * Maximum number of atoms on each cluster that can be considered to be simulated together. It affects the the quality and speed of the simulation.\n   * @default 8\n   */\n  maxClusterSize?: number;\n  /**\n   * The frequency in Mhz of the fake spectrometer that records the spectrum.\n   * @default 400\n   */\n  frequency?: number;\n  /**\n   * The low limit of the ordinate variable.\n   * @default 0\n   */\n  from?: number;\n  /**\n   * The upper limit of the ordinate variable.\n   * @default 10\n   */\n  to?: number;\n  /**\n   * Number of points of the output spectrum.\n   * @default 16K\n   */\n  nbPoints?: number;\n  /**\n   * Shape options\n   * @default {kind:'gaussian'}\n   */\n  shape?: Shape1DOption;\n}\n\n/**\n * This function simulates a one dimensional nmr spectrum. This function returns an array containing the relative intensities of the spectrum in the specified simulation window (from-to).\n */\n\nexport default function simulate1D(\n  /**\n   * The SpinSystem object to be simulated\n   */\n  spinSystem: SpinSystem,\n  options: Simulate1DOptions = {},\n) {\n  let {\n    lineWidth = 1,\n    maxClusterSize = 8,\n    frequency: frequencyMHz = 400,\n    from = 0,\n    to = 10,\n    nbPoints = 1024,\n    shape = {\n      kind: 'gaussian',\n    },\n  } = options;\n\n  let peakWidth = lineWidth / frequencyMHz;\n\n  let spectrumGenerator = new SpectrumGenerator({\n    from,\n    to,\n    nbPoints,\n    shape,\n    peakWidthFct: () => peakWidth,\n  });\n\n  const chemicalShifts = spinSystem.chemicalShifts.slice();\n  for (let i = 0; i < chemicalShifts.length; i++) {\n    chemicalShifts[i] = chemicalShifts[i] * frequencyMHz;\n  }\n\n  const multiplicity = spinSystem.multiplicity;\n  for (const cluster of spinSystem.clusters) {\n    let clusterFake = cluster.map((cluster) =>\n      cluster < 0 ? -cluster - 1 : cluster,\n    );\n\n    let weight = 1;\n    let sumI = 0;\n    let frequencies: number[] = [];\n    let intensities: number[] = [];\n    if (cluster.length > maxClusterSize) {\n      // This is a single spin, but the cluster exceeds the maxClusterSize criteria\n      // we use the simple multiplicity algorithm\n      // Add the central peak. It will be split with every single J coupling.\n      let index = 0;\n      while (cluster[index++] < 0);\n      index = cluster[index - 1];\n      frequencies.push(-chemicalShifts[index]);\n      for (let i = 0; i < cluster.length; i++) {\n        if (cluster[i] < 0) {\n          let jc = spinSystem.couplingConstants.get(index, clusterFake[i]) / 2;\n          let currentSize = frequencies.length;\n          for (let j = 0; j < currentSize; j++) {\n            frequencies.push(frequencies[j] + jc);\n            frequencies[j] -= jc;\n          }\n        }\n      }\n\n      frequencies.sort((a, b) => a - b);\n      sumI = frequencies.length;\n      weight = 1;\n\n      for (let i = 0; i < sumI; i++) {\n        intensities.push(1);\n      }\n    } else {\n      const hamiltonian = getHamiltonian(\n        chemicalShifts,\n        spinSystem.couplingConstants,\n        multiplicity,\n        spinSystem.connectivity,\n        clusterFake,\n      );\n      const hamSize = hamiltonian.rows;\n      //@ts-expect-error\n      const evd = new EVD(hamiltonian);\n      const V = evd.eigenvectorMatrix;\n      const diagB = evd.realEigenvalues;\n      const assignmentMatrix = new SparseMatrix(hamSize, hamSize);\n      const multLen = cluster.length;\n      weight = 0;\n      for (let n = 0; n < multLen; n++) {\n        const L = getPauliMatrix(multiplicity[clusterFake[n]]);\n\n        let temp = 1;\n        for (let j = 0; j < n; j++) {\n          temp *= multiplicity[clusterFake[j]];\n        }\n        const A = SparseMatrix.eye(temp);\n\n        temp = 1;\n        for (let j = n + 1; j < multLen; j++) {\n          temp *= multiplicity[clusterFake[j]];\n        }\n        const B = SparseMatrix.eye(temp);\n        const tempMat = A.kroneckerProduct(L.m).kroneckerProduct(B);\n        if (cluster[n] >= 0) {\n          assignmentMatrix.add(tempMat.mul(cluster[n] + 1));\n          weight++;\n        } else {\n          assignmentMatrix.add(tempMat.mul(cluster[n]));\n        }\n      }\n\n      let rhoip = Matrix.zeros(hamSize, hamSize);\n      assignmentMatrix.forEachNonZero((i, j, v) => {\n        if (v > 0) {\n          for (let k = 0; k < V.columns; k++) {\n            let element = V.get(j, k);\n            if (element !== 0) {\n              rhoip.set(i, k, rhoip.get(i, k) + element);\n            }\n          }\n        }\n        return v;\n      });\n\n      let rhoip2 = rhoip.clone();\n      assignmentMatrix.forEachNonZero((i: number, j: number, v: number) => {\n        if (v < 0) {\n          for (let k = 0; k < V.columns; k++) {\n            let element = V.get(j, k);\n            if (element !== 0) {\n              rhoip2.set(i, k, rhoip2.get(i, k) + element);\n            }\n          }\n        }\n        return v;\n      });\n      const tV = V.transpose();\n\n      rhoip = tV.mmul(rhoip);\n      const sparseRhoip = new SparseMatrix(rhoip.to2DArray(), {\n        threshold: smallValue,\n      });\n      triuTimesAbs(sparseRhoip, smallValue);\n\n      rhoip2 = tV.mmul(rhoip2);\n      const sparseRhoip2 = new SparseMatrix(rhoip2.to2DArray(), {\n        threshold: smallValue,\n      });\n      sparseRhoip2.forEachNonZero((i, j, v) => {\n        return v;\n      });\n      triuTimesAbs(sparseRhoip2, smallValue);\n      sparseRhoip2.forEachNonZero((i, j, v) => {\n        let val = rhoip.get(i, j);\n        val = Math.min(Math.abs(val), Math.abs(v));\n        val *= val;\n\n        sumI += val;\n        let valFreq = diagB[i] - diagB[j];\n        let insertIn = binarySearch(\n          frequencies,\n          valFreq,\n          (a: number, b: number) => a - b,\n        );\n        if (insertIn < 0) {\n          frequencies.splice(-1 - insertIn, 0, valFreq);\n          intensities.splice(-1 - insertIn, 0, val);\n        } else {\n          intensities[insertIn] += val;\n        }\n      });\n    }\n\n    const numFreq = frequencies.length;\n\n    if (numFreq > 0) {\n      weight /= sumI;\n      const diff = lineWidth / 64;\n      let valFreq = frequencies[0];\n      let inte = intensities[0];\n      let count = 1;\n      for (let i = 1; i < numFreq; i++) {\n        if (Math.abs(frequencies[i] - valFreq / count) < diff) {\n          inte += intensities[i];\n          valFreq += frequencies[i];\n          count++;\n        } else {\n          spectrumGenerator.addPeak({\n            x: -valFreq / count / frequencyMHz,\n            y: inte * weight,\n          });\n          valFreq = frequencies[i];\n          inte = intensities[i];\n          count = 1;\n        }\n      }\n\n      spectrumGenerator.addPeak({\n        x: -valFreq / count / frequencyMHz,\n        y: inte * weight,\n      });\n    }\n  }\n  return spectrumGenerator.getSpectrum();\n}\n\nfunction triuTimesAbs(A: SparseMatrix, val: number) {\n  A.forEachNonZero((i, j, v) => {\n    if (i > j) return 0;\n    if (Math.abs(v) <= val) return 0;\n    return v;\n  });\n}\n/**\n * Create a hamiltonian matrix for the given spinsystem\n * @param {Array} chemicalShifts - An array containing the chemical shift in Hz\n * @param {Array} couplingConstants - An array containing the coupling constants in Hz\n * @param {Array} multiplicity - An array specifiying the multiplicities of each scalar coupling\n * @param {Array} conMatrix - A one step connectivity matrix for the given spin system\n * @param {Array} cluster - An binary array specifiying the spins to be considered for this hamiltonial\n * @return {object}\n */\nfunction getHamiltonian(\n  chemicalShifts: number[],\n  couplingConstants: MatrixClassType,\n  multiplicity: number[],\n  conMatrix: MatrixClassType,\n  cluster: number[],\n) {\n  let hamSize = 1;\n  for (const element of cluster) {\n    hamSize *= multiplicity[element];\n  }\n\n  const clusterHam = new SparseMatrix(hamSize, hamSize);\n\n  for (let pos = 0; pos < cluster.length; pos++) {\n    let n = cluster[pos];\n\n    const L = getPauliMatrix(multiplicity[n]);\n\n    let A1, B1;\n    let temp = 1;\n    for (let i = 0; i < pos; i++) {\n      temp *= multiplicity[cluster[i]];\n    }\n    A1 = SparseMatrix.eye(temp);\n\n    temp = 1;\n    for (let i = pos + 1; i < cluster.length; i++) {\n      temp *= multiplicity[cluster[i]];\n    }\n    B1 = SparseMatrix.eye(temp);\n\n    const alpha = chemicalShifts[n];\n    const kronProd = A1.kroneckerProduct(L.z).kroneckerProduct(B1);\n    clusterHam.add(kronProd.mul(alpha));\n    for (let pos2 = 0; pos2 < cluster.length; pos2++) {\n      const k = cluster[pos2];\n      if (conMatrix.get(n, k) === 1) {\n        const S = getPauliMatrix(multiplicity[k]);\n\n        let A2, B2;\n        let temp = 1;\n        for (let i = 0; i < pos2; i++) {\n          temp *= multiplicity[cluster[i]];\n        }\n        A2 = SparseMatrix.eye(temp);\n\n        temp = 1;\n        for (let i = pos2 + 1; i < cluster.length; i++) {\n          temp *= multiplicity[cluster[i]];\n        }\n        B2 = SparseMatrix.eye(temp);\n\n        const kron1 = A1.kroneckerProduct(L.x)\n          .kroneckerProduct(B1)\n          .mmul(A2.kroneckerProduct(S.x).kroneckerProduct(B2));\n        kron1.add(\n          A1.kroneckerProduct(L.y)\n            .kroneckerProduct(B1)\n            .mul(-1)\n            .mmul(A2.kroneckerProduct(S.y).kroneckerProduct(B2)),\n        );\n        kron1.add(\n          A1.kroneckerProduct(L.z)\n            .kroneckerProduct(B1)\n            .mmul(A2.kroneckerProduct(S.z).kroneckerProduct(B2)),\n        );\n\n        clusterHam.add(kron1.mul(couplingConstants.get(n, k) / 2));\n      }\n    }\n  }\n  return clusterHam;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\splitSpinSystem.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\simulation\\__tests__\\splitSpinSystem.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsJoin.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsToRanges.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\signals\\__tests__\\signalsToXY.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-matrix-convolution\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-matrix-peaks-finder\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-simple-clustering\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-sparse-matrix\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-spectra-processing\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\joinPatterns.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\resurrect.ts",["440","441","442","443","444","445"],"import type { NMRRange } from '../types/NMRRange';\n\nimport { resurrectRange } from './resurrectRange';\nimport { splitParenthesis } from './splitParenthesis';\n\nexport interface DataResurrect {\n  experiment: {\n    solvent?: string;\n    frequency?: number;\n    nucleus?: string;\n  };\n  ranges: NMRRange[];\n  acsString: string;\n  normalized: string;\n  parts: string[];\n}\n\nexport function resurrect(acsString: string) {\n  const data: any = {\n    experiment: {},\n    ranges: [],\n    acsString,\n    normalized: acsString\n      .replace(/[\\r\\n\\t]/g, ' ')\n      .replace(/[;:]/g, ',')\n      .replace(/\\}/g, ')')\n      .replace(/\\{/g, '(')\n      .replace(/[\\u2011\\u2012\\u2013\\u2014\\u2015\\u2212]/g, '-'),\n  };\n  createParts(data);\n  parseParts(data);\n  return data;\n}\n\nfunction parseParts(data: DataResurrect) {\n  for (const part of data.parts) {\n    if (part.toLowerCase().includes('nmr')) {\n      processExperiment(data, part);\n    } else {\n      const { frequency, nucleus } = data.experiment;\n      const range = resurrectRange(part, { frequency, nucleus });\n      if (range) data.ranges.push(range);\n    }\n  }\n}\n\nfunction processExperiment(data: DataResurrect, part: string) {\n  const split = splitParenthesis(part);\n  const before = split.before\n    .replace(/[ -]*nmr[ -]*/i, '')\n    .replace(/[ -]/g, '');\n  if (/^[0-9]+[A-Z][a-z]?$/.exec(before)) {\n    // 36Cl, 1H, 13C, ...\n    data.experiment.nucleus = before;\n  }\n  if (/^[A-Z][a-z]?[0-9]+$/.exec(before)) {\n    // Cl35, H1, C13, ...\n    data.experiment.nucleus = before.replace(/^([A-Z][a-z]?)([0-9]+)$/, '$2$1');\n  }\n  if (split.inside) {\n    // some frequency and solvent ???\n    const insideParts = split.inside.split(/[,]/);\n    const frequencyParts = insideParts.filter((part: string) =>\n      /[0-9]{2}/.exec(part),\n    );\n    if (frequencyParts.length) {\n      const frequency = frequencyParts[0].replace(/[^0-9]/g, '');\n\n      if (frequency.length > 1) data.experiment.frequency = Number(frequency);\n    }\n    const solventParts = insideParts.filter(\n      (part: any) => !part.match(/[0-9]{2}/),\n    );\n    if (solventParts.length) {\n      data.experiment.solvent = solventParts[0];\n    }\n  }\n}\n\nfunction createParts(data: DataResurrect) {\n  const parts = data.normalized\n    .split(/\\)(?![^()]*\\))/)\n    .map((part) => part.replace(/^\\s*(.*?)\\s*$/, '$1'))\n    .filter((part) => part)\n    .map((part) => `${part})`)\n    .map((part) => part.split(/[,;](?![^()]*\\))/))\n    .flat()\n    .map((part) => part.replace(/^\\s*(.*?)\\s*$/, '$1'))\n    .filter((part) => part);\n  data.parts = parts;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\splitPatterns.ts",["446"],"export function splitPatterns(multiplet: string) {\n  if (/^\\s*$/.exec(multiplet)) return [];\n  let result = multiplet.match(\n    / *(quint|hex|sept|hept|oct|nona|non|s|d|t|q|h|o|n) */g,\n  );\n  if (result) return result.map((entry) => entry.trim());\n  return [multiplet];\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\joinPatterns.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\resurrect.test.ts",["447","448","449"],"/* eslint-disable no-tabs */\n\nimport { resurrect } from '../resurrect';\n\ndescribe('resurrect', () => {\n  it.skip('angewandte Chemie', () => {\n    const string = `\n\t1H-NMR (400 MHz, CDCl3) 5.96 (dd, J1 = 10.0 Hz, J2 = 5.4 Hz, 1 H), 5.71 (dd, J1 = \n\t10.1 Hz, J2 = 1.1 Hz, 1 H), 5.14 (br. s, 1 H), 4.71 (dd, J1 = 11.1 Hz, J2 = 3.7 Hz, 1 H), \n\t4.07 (sept., J = 6.2 Hz, 1 H), 2.41 (dd, J1 = 17.7 Hz, J2 = 11.2 Hz, 1 H), 2.23 (dd, J1 = \n\t17.7 Hz, J2 = 4.1 Hz, 1 H), 1.29 (d, J = 6.2 Hz, 3 H), 1.19 (d, J = 6.1 Hz, 3 H), 1.00 (t, \n\tJ = 7.8 Hz, 9 H), 0.63 (q, J = 7.8 Hz, 6 H).`;\n    const ranges = resurrect(string).ranges;\n    expect(ranges).toMatchSnapshot();\n  });\n\n  it.skip('JOC', () => {\n    const string = `\n\tH-NMR (CDCl, 300 MHz) 3.68 (s, 2H), 3.70-3.74 (m, 4H), 3.93 (dd, 1H, J = 9.7, \n\tJ2 = 3.7), 4.49 (d, 2 H, J = 4.1), 4.56-4.61 (m, 1H), 5.12 (s, 2H), 5.81 (d, 1H, J = 7.5), \n\t7.24-7.37 (m, 10H).`;\n    const ranges = resurrect(string).ranges;\n    expect(ranges).toMatchSnapshot();\n  });\n\n  it('Tetrahedron', () => {\n    const string = `\n\t1H NMR (CDCl3, 400 MHz) d: 5.55 (d, J = 8.1 Hz, 1H, H-10 ), 4.72 (br s, 1H),\n\t4.29 (m, 1H, H-50 ), 3.53 (m, 2H, H-30 , H-40 ), 3.42  \n\t(m, 1H, H-20 ), 3.15 (dd, J = 6.0 Hz, J = 10.0 Hz, 1H, H-3), 3.00 (td, J = 11.0 Hz,  \n\tJ = 4.5 Hz, 1H, H-19), 1.69 (s, 1H, H-30)\n`;\n    const ranges = resurrect(string).ranges;\n    expect(ranges).toMatchSnapshot();\n  });\n\n  it.skip('Parenthesis', () => {\n    const string = `\n1H NMR (400 MHz, CDCl3): d/ppm 0.89 (t, 3H, J = 7.0 Hz, CH3), 1.23-1.45 {m, 24H, CH3(CH2)12- \n}, 1.77 (qt, 2H, J = 7.4 Hz, -CH2CH2COO-), 2.58 (t, 2H, J = 7.5 Hz, -CH2COO-), 7.14 (d, 2H, J = \n8.7 Hz, Ar-H), 7.26 (d, 2H, J = 8.7 Hz, Ar-H), 7.41 (dd, 1H, J = 7.8 Hz, 4.9 Hz, Ar-H), 8.30 (d, 1H, \nJ = 7.9 Hz, Ar-H), 8.51 (s, 1H, CH=N), 8.71 (dd, 1H, J = 4.7 Hz, 1.4 Hz, Ar-H), 9.02 (d, 1H, J = \n1.4 Hz, Ar-H). \n`;\n    const ranges = resurrect(string).ranges;\n    expect(ranges).toMatchSnapshot();\n  });\n\n  it('J. Org. Chem.', () => {\n    const string = `1H NMR (CDCl3)  10.58 (b, 1H), 7.40 (d, 1H, J = 8.0 Hz), 6.19 (d, 1H, J = 7.6 Hz), 4.88 (s, 1H), 4.46 (m, 1H), 4.25 (m, 1H), 4.08 (m, 1H), 3.903.95 (m, 2H), 2.17 (s, 3H), 1.02 (s, 9H), 1.01 (s, 9H), 0.89 (s, 9H), 0.12 (s, 3H), 0.11 (s, 3H)`;\n    const ranges = resurrect(string).ranges;\n    expect(ranges).toMatchSnapshot();\n  });\n});\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\splitPatterns.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\xyAutoPeaksPicking.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\xyAutoRangesPicking.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\__tests__\\xyAutoPeaksPicking.test.ts",["450"],"import { toBeDeepCloseTo, toMatchCloseTo } from 'jest-matcher-deep-close-to';\nimport { getShape1D } from 'ml-peak-shape-generator';\nimport noisyBigPeakSmallPeak from 'nmr-xy-testdata/data/noisy/noisyBigPeakSmallPeak.json';\nimport tripletQuadruplet from 'nmr-xy-testdata/data/pure/d1-2_j7.json';\n\nimport { xyAutoPeaksPicking } from '../xyAutoPeaksPicking';\n\nexpect.extend({ toBeDeepCloseTo, toMatchCloseTo });\n\ndescribe('xyAutoPeaksPicking', () => {\n  it('a triplet and a quadruple', () => {\n    let options = {};\n\n    let peaks = xyAutoPeaksPicking(tripletQuadruplet, options);\n\n    const widthToFWHM = getShape1D('gaussian').widthToFWHM;\n    expect(peaks).toHaveLength(7);\n    expect(peaks[1].x).toBeDeepCloseTo(0.999831, 3);\n    expect(peaks[1].y / 100).toBeDeepCloseTo(14846602893.68, 1);\n    expect(peaks[1].shape.width).toBeDeepCloseTo(\n      widthToFWHM(0.0021514892578125),\n      3,\n    );\n  });\n  it('mixed spectrum with small and big peaks', () => {\n    let options = {\n      thresholdFactor: 3,\n      compile: false,\n      clean: false,\n      optimize: false,\n      minMaxRatio: 0.01,\n      integralType: 'sum',\n      nH: 3,\n      frequencyCluster: 16,\n      widthFactor: 4,\n      smoothY: false,\n      broadWidth: 0.2,\n      shape: { kind: 'lorentzian' },\n      broadRatio: 0,\n    };\n\n    let peaks = xyAutoPeaksPicking(noisyBigPeakSmallPeak, options);\n    const widthToFWHM = getShape1D('lorentzian').widthToFWHM;\n\n    const expectedResult: { [key: string]: any }[] = [\n      { x: 2, y: 6.2683, shape: { width: widthToFWHM(0.4) } },\n      { x: 8, y: 316.503, shape: { width: widthToFWHM(0.4) } },\n    ];\n\n    expectedResult.forEach((expected, i) => {\n      let peak = peaks[i];\n      for (let key in expected) {\n        //@ts-expect-error\n        if (typeof peak[key] === 'object') {\n          //@ts-expect-error\n          expect(peak[key]).toMatchCloseTo(expected[key], 2);\n        } else {\n          //@ts-expect-error\n          expect(peak[key]).toBeCloseTo(expected[key], 2);\n        }\n      }\n    });\n  });\n\n  it('negative spectrum', () => {\n    let y = tripletQuadruplet.y;\n    for (let i = 0; i < y.length; i++) {\n      y[i] *= -1;\n    }\n    tripletQuadruplet.y = y;\n    let options = { lookNegative: true };\n\n    let peaks = xyAutoPeaksPicking(tripletQuadruplet, options);\n    expect(peaks).toHaveLength(7);\n    expect(peaks[1].x).toBeDeepCloseTo(0.999831, 3);\n    expect(peaks[1].y / 100).toBeDeepCloseTo(-14846602893.68, 1);\n    expect(peaks[1].shape.width).toBeDeepCloseTo(0.0021514892578125, 3);\n  });\n});\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xy\\__tests__\\xyAutoRangesPicking.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xyz\\xyzAutoPeaksPicking.ts",["451"],"import { Matrix } from 'ml-matrix';\nimport * as convolution from 'ml-matrix-convolution';\nimport * as matrixPeakFinders from 'ml-matrix-peaks-finder';\nimport simpleClustering from 'ml-simple-clustering';\n\nimport { determineRealTop } from '../peaks/util/determineRealTop';\nimport { getKernel } from '../peaks/util/getKernel';\nimport type { GetKernelOptions } from '../peaks/util/getKernel';\nimport * as PeakOptimizer from '../peaks/util/peakOptimizer';\nimport type { MPFPeak } from '../types/MPFPeak';\nimport type { NMRSignal2D } from '../types/NMRSignal2D';\n\nconst smallFilter = [\n  [0, 0, 1, 2, 2, 2, 1, 0, 0],\n  [0, 1, 4, 7, 7, 7, 4, 1, 0],\n  [1, 4, 5, 3, 0, 3, 5, 4, 1],\n  [2, 7, 3, -12, -23, -12, 3, 7, 2],\n  [2, 7, 0, -23, -40, -23, 0, 7, 2],\n  [2, 7, 3, -12, -23, -12, 3, 7, 2],\n  [1, 4, 5, 3, 0, 3, 5, 4, 1],\n  [0, 1, 3, 7, 7, 7, 3, 1, 0],\n  [0, 0, 1, 2, 2, 2, 1, 0, 0],\n];\n\nexport interface Data2D {\n  z: number[][] | Float64Array[];\n  minX: number;\n  maxX: number;\n  minY: number;\n  maxY: number;\n}\n\nexport interface XYZAutoPeaksPickingOptions {\n  /**\n   * max number of points in any dimension to pad the input data, this is needed to avoid lost peaks when the input matrix is too small.\n   * @default 14\n   */\n  sizeToPad?: number;\n  /**\n   * If it's true, try to find the real maximum for each bidimensional peak.\n   * @default true\n   */\n  realTopDetection?: boolean;\n  /**\n   * positive value filter small peaks by intensity\n   * @default 0.5\n   */\n  thresholdFactor?: number;\n  /**\n   * specify the nuclei of each dimension\n   * @default ['1H','1H']\n   */\n  nuclei?: string[];\n  /**\n   * specify the frequency for each dimension.\n   */\n  observedFrequencies: number[] | Float64Array;\n  /**\n   * If it's true, it try to ajust the shift and add missing cross peaks, useful only for homonuclear data.\n   * @default false\n   */\n  enhanceSymmetry?: boolean;\n  /**\n   * If it's true, peaks with less than a specific percentage (maxPercentCutOff) of the maximum intensity will be removed.\n   * @default true;\n   */\n  clean?: boolean;\n  /**\n   * percentage of maximum intensity as cutoff for small peaks.\n   * @default 0.03\n   */\n  maxPercentCutOff?: number;\n  /**\n   * Specify the minimum distance in Hz for each dimension to join peaks in a signal.\n   * @default [24,24]\n   */\n  tolerances?: number[];\n  /**\n   * If it is true, the convolution will be forced by FFT\n   * @default true\n   */\n  convolutionByFFT?: boolean;\n  /**\n   * kernel options to calculate a laplacianOfGaussian kernel with a specify size.\n   */\n  kernel?: GetKernelOptions;\n}\n\nexport function xyzAutoPeaksPicking(\n  spectraData: Data2D,\n  options: XYZAutoPeaksPickingOptions,\n) {\n  let {\n    sizeToPad = 14,\n    realTopDetection = true,\n    thresholdFactor = 0.5,\n    nuclei = ['1H', '1H'],\n    observedFrequencies,\n    enhanceSymmetry = false,\n    clean = true,\n    maxPercentCutOff = 0.03,\n    tolerances = [24, 24],\n    convolutionByFFT = true,\n    kernel: kernelOptions,\n  } = options;\n\n  if (\n    !Array.isArray(observedFrequencies) &&\n    !ArrayBuffer.isView(observedFrequencies)\n  ) {\n    throw new Error('observedFrequencies is mandatory');\n  }\n\n  thresholdFactor = thresholdFactor === 0 ? 1 : Math.abs(thresholdFactor);\n\n  let nbPoints = spectraData.z[0].length;\n  let nbSubSpectra = spectraData.z.length;\n\n  if (nbSubSpectra < sizeToPad) {\n    spectraData = padData(spectraData, { width: sizeToPad });\n    nbPoints = spectraData.z[0].length;\n    nbSubSpectra = spectraData.z.length;\n  }\n\n  let absoluteData = new Float64Array(nbPoints * nbSubSpectra);\n  let originalData = new Float64Array(nbPoints * nbSubSpectra);\n\n  for (let iSubSpectra = 0; iSubSpectra < nbSubSpectra; iSubSpectra++) {\n    let spectrum = spectraData.z[iSubSpectra];\n    for (let iCol = 0; iCol < nbPoints; iCol++) {\n      let index = iSubSpectra * nbPoints + iCol;\n      absoluteData[index] = Math.abs(spectrum[iCol]);\n      originalData[index] = spectrum[iCol]; //@todo pensar si se puede evitar originalData\n    }\n  }\n\n  const kernel = kernelOptions ? getKernel(kernelOptions) : smallFilter;\n\n  let convolutedSpectrum = convolutionByFFT\n    ? convolution.fft(absoluteData, kernel, {\n        rows: nbSubSpectra,\n        cols: nbPoints,\n      })\n    : convolution.direct(absoluteData, kernel, {\n        rows: nbSubSpectra,\n        cols: nbPoints,\n      });\n\n  let peaksMC1 = matrixPeakFinders.findPeaks2DRegion(absoluteData, {\n    originalData,\n    filteredData: convolutedSpectrum,\n    rows: nbSubSpectra,\n    cols: nbPoints,\n    nStdDev: thresholdFactor,\n  });\n\n  if (clean) {\n    // Remove peaks with less than x% of the intensity of the highest peak\n    peaksMC1 = PeakOptimizer.clean(peaksMC1, maxPercentCutOff);\n  }\n\n  let signals = createSignals2D(peaksMC1, {\n    nRows: nbSubSpectra,\n    nCols: nbPoints,\n    minX: spectraData.minX,\n    maxX: spectraData.maxX,\n    minY: spectraData.minY,\n    maxY: spectraData.maxY,\n    absoluteData,\n    originalData,\n    tolerances,\n    nuclei,\n    observedFrequencies,\n    realTopDetection,\n  });\n\n  if (enhanceSymmetry) {\n    signals = PeakOptimizer.enhanceSymmetry(signals);\n  }\n\n  return signals;\n}\n\n/**\n * This function converts a set of 2D-peaks in 2D-signals. Each signal could be composed\n * of many 2D-peaks, and it has some additional information related to the NMR spectrum.\n * @private\n */\n\nexport interface CreateSignals2DOptions {\n  nCols: number;\n  nRows: number;\n  absoluteData: number[] | Float64Array;\n  originalData: number[] | Float64Array;\n  observedFrequencies: number[] | Float64Array;\n  tolerances: number[];\n  nuclei: string[];\n  realTopDetection: boolean;\n  minY: number;\n  maxY: number;\n  minX: number;\n  maxX: number;\n}\nconst createSignals2D = (peaks: MPFPeak[], options: CreateSignals2DOptions) => {\n  let {\n    nCols,\n    nRows,\n    absoluteData,\n    originalData,\n    observedFrequencies,\n    tolerances,\n    nuclei,\n    realTopDetection,\n    minY,\n    maxY,\n    minX,\n    maxX,\n  } = options;\n\n  let [nucleusX, nucleusY] = nuclei;\n  let [toleranceX, toleranceY] = tolerances;\n  let [observeFrequencyX, observeFrequencyY] = observedFrequencies;\n\n  let dy = (maxY - minY) / (nRows - 1);\n  let dx = (maxX - minX) / (nCols - 1);\n\n  if (realTopDetection) {\n    peaks = determineRealTop(peaks, {\n      nCols,\n      absoluteData,\n      originalData,\n      minX,\n      maxX,\n      minY,\n      maxY,\n    });\n  }\n\n  for (let i = peaks.length - 1; i >= 0; i--) {\n    let { x, y } = peaks[i];\n    peaks[i].x = minX + dx * x;\n    peaks[i].y = minY + dy * y;\n    peaks[i].minX = minX + dx * peaks[i].minX;\n    peaks[i].minY = minY + dy * peaks[i].minY;\n    peaks[i].maxX = minX + dx * peaks[i].maxX;\n    peaks[i].maxY = minY + dy * peaks[i].maxY;\n\n    // Still having problems to correctly detect peaks on those areas. So I'm removing everything there.\n    if (peaks[i].y < -1 || peaks[i].y >= 210) {\n      peaks.splice(i, 1);\n    }\n  }\n  // The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n  // array like form\n  let connectivity = [];\n  for (let i = 0; i < peaks.length; i++) {\n    for (let j = i; j < peaks.length; j++) {\n      if (\n        Math.abs(peaks[i].x - peaks[j].x) * observeFrequencyX < toleranceX &&\n        Math.abs(peaks[i].y - peaks[j].y) * observeFrequencyY < toleranceY\n      ) {\n        // 24*24Hz We cannot distinguish peaks with less than 20 Hz of separation\n        connectivity.push(1);\n      } else {\n        connectivity.push(0);\n      }\n    }\n  }\n  let clusters = simpleClustering(connectivity);\n\n  let signals: NMRSignal2D[] = [];\n  if (clusters) {\n    for (const cluster of clusters) {\n      let signal: any = {\n        x: {\n          delta: 0,\n          nucleus: nucleusX,\n          resolution: dx,\n        },\n        y: {\n          delta: 0,\n          nucleus: nucleusY,\n          resolution: dy,\n        },\n      };\n      let peaks2D = [];\n      let minMax1 = [Number.MAX_VALUE, 0];\n      let minMax2 = [Number.MAX_VALUE, 0];\n      let sumZ = 0;\n\n      for (let jPeak = 0; jPeak < cluster.length; jPeak++) {\n        if (cluster[jPeak] === 1) {\n          peaks2D.push(peaks[jPeak]);\n          signal.x.delta += peaks[jPeak].x * peaks[jPeak].z;\n          signal.y.delta += peaks[jPeak].y * peaks[jPeak].z;\n          sumZ += peaks[jPeak].z;\n          if (peaks[jPeak].minX < minMax1[0]) {\n            minMax1[0] = peaks[jPeak].minX;\n          }\n          if (peaks[jPeak].maxX > minMax1[1]) {\n            minMax1[1] = peaks[jPeak].maxX;\n          }\n          if (peaks[jPeak].minY < minMax2[0]) {\n            minMax2[0] = peaks[jPeak].minY;\n          }\n          if (peaks[jPeak].maxY > minMax2[1]) {\n            minMax2[1] = peaks[jPeak].maxY;\n          }\n        }\n      }\n\n      signal.x.fromTo = { from: minMax1[0], to: minMax1[1] };\n      signal.y.fromTo = { from: minMax2[0], to: minMax2[1] };\n      signal.x.delta /= sumZ;\n      signal.y.delta /= sumZ;\n      signal.peaks = peaks2D;\n      signals.push(signal as NMRSignal2D);\n    }\n  }\n  return signals;\n};\n\nconst padData = (spectraData: Data2D, options: { width: number }) => {\n  let { minX, maxX, minY, maxY } = spectraData;\n\n  const width = options.width;\n\n  let nbPoints = spectraData.z[0].length;\n  let nbSubSpectra = spectraData.z.length;\n\n  let yInterval = (maxY - minY) / (nbSubSpectra - 1);\n  let xInterval = (maxX - minX) / (nbPoints - 1);\n\n  let yDiff = width - nbSubSpectra;\n  let xDiff = Math.max(width - nbPoints, 0);\n  if (xDiff % 2) xDiff++;\n  if (yDiff % 2) yDiff++;\n\n  let xOffset = xDiff / 2;\n  let yOffset = yDiff / 2;\n  let newMatrix = Matrix.zeros(nbSubSpectra + yDiff, nbPoints + xDiff);\n  for (let i = 0; i < nbSubSpectra; i++) {\n    for (let j = 0; j < nbPoints; j++) {\n      newMatrix.set(i + yOffset, j + xOffset, spectraData.z[i][j]);\n    }\n  }\n\n  return {\n    z: newMatrix.to2DArray(),\n    minX: minX - xOffset * xInterval,\n    maxX: maxX + xOffset * xInterval,\n    minY: minY - yOffset * yInterval,\n    maxY: maxY + yOffset * yInterval,\n  };\n};\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\xyz\\xyzJResAnalyzer.ts",["452","453"],"import simpleClustering from 'ml-simple-clustering';\n\nimport type { JAxisKeys } from '../peaks/util/jAnalyzer';\nimport jAnalyzer from '../peaks/util/jAnalyzer';\nimport type { MPFPeak } from '../types/MPFPeak';\nimport type { MakeMandatory } from '../types/MakeMandatory';\nimport type { NMRSignal2D } from '../types/NMRSignal2D';\n\ninterface CompilePatternOptions {\n  observedFrequencies?: number[] | Float64Array;\n  tolerances?: number[] | Float64Array;\n  nuclei?: string[];\n  jAnalyzer?: { jAxisKey: JAxisKeys };\n}\n\ninterface XYZJResAnalyzerOptions extends CompilePatternOptions {\n  /**\n   * maximum difference in Hz to discard if the signal is symmetric.\n   * @default 0.08\n   */\n  referenceMaxShiftError?: number;\n  /**\n   * reference value in Hz\n   * @default 0\n   */\n  reference?: number;\n}\n\ntype CompilePatternOptionsMandatory = MakeMandatory<\n  CompilePatternOptions,\n  'observedFrequencies' | 'tolerances' | 'nuclei' | 'jAnalyzer'\n>;\n\nexport function xyzJResAnalyzer(\n  signals: NMRSignal2D[],\n  options: XYZJResAnalyzerOptions = {},\n) {\n  let {\n    reference = 0,\n    referenceMaxShiftError = 0.08,\n    tolerances = [10, 100],\n    nuclei = ['1H', '1H'],\n    observedFrequencies = [400, 400],\n    jAnalyzer = {\n      jAxisKey: { jAxis: 'y', intensity: 'z' },\n    },\n  } = options;\n  let temporalSignals = compilePattern(signals, {\n    observedFrequencies,\n    tolerances,\n    nuclei,\n    jAnalyzer,\n  });\n  //check if the signal are symmetric around the reference\n  let result = [];\n  for (const tempSignal of temporalSignals) {\n    let delta = tempSignal.y.delta;\n    if (Math.abs(delta - reference) > referenceMaxShiftError) continue;\n    result.push(tempSignal);\n  }\n  return result;\n}\n\nfunction compilePattern(\n  signals: NMRSignal2D[],\n  options: CompilePatternOptionsMandatory,\n) {\n  let {\n    observedFrequencies,\n    tolerances,\n    nuclei,\n    jAnalyzer: jAnalyzerOptions,\n  } = options;\n\n  let signalOptions = {\n    observedFrequencies,\n    tolerances,\n    nuclei,\n    dx: signals[0].x.resolution,\n    dy: signals[0].y.resolution,\n  };\n\n  const newSignals = JSON.parse(JSON.stringify(signals));\n  //adapt to 1D jAnalyzer\n  for (const signal of newSignals) {\n    let peaks = signal.peaks;\n    signal.nbPeaks = signal.peaks.length;\n    signal.multiplicity = '';\n    signal.pattern = '';\n    signal.delta1 = signal.shiftY;\n    signal.observe = observedFrequencies[1];\n    signal.integralData = {\n      from: Number.MAX_SAFE_INTEGER,\n      to: Number.MIN_SAFE_INTEGER,\n    };\n    for (const peak of peaks) {\n      if (!peak.width) peak.width = 0.02;\n    }\n    peaks.sort((a: MPFPeak, b: MPFPeak) => a.y - b.y);\n  }\n\n  for (let i = 0; i < signals.length; i++) {\n    jAnalyzer.compilePattern(newSignals[i], jAnalyzerOptions);\n\n    if (\n      newSignals[i].maskPattern &&\n      newSignals[i].multiplicity !== 'm' &&\n      newSignals[i].multiplicity !== ''\n    ) {\n      // Create a new signal with the removed peaks\n      let peaksO = [];\n      for (let j = newSignals[i].maskPattern.length - 1; j >= 0; j--) {\n        if (newSignals[i].maskPattern[j] === false) {\n          let peakR = newSignals[i].peaks.splice(j, 1)[0];\n          peaksO.push(peakR);\n          newSignals[i].mask.splice(j, 1);\n          newSignals[i].mask2.splice(j, 1);\n          newSignals[i].maskPattern.splice(j, 1);\n          newSignals[i].nbPeaks--;\n        }\n      }\n      if (peaksO.length > 0) {\n        peaksO.reverse();\n        let ranges = createSignals2D(peaksO, signalOptions);\n\n        for (const range of ranges) {\n          newSignals.push(range);\n        }\n      }\n    }\n  }\n\n  signals.sort((a, b) => {\n    return b.x.delta - a.x.delta;\n  });\n\n  return signals;\n}\n\ninterface Peak2DHack extends MPFPeak {\n  width?: number;\n}\ntype Signal2DHack = Omit<NMRSignal2D, 'peaks'> & {\n  peaks: Peak2DHack[];\n  integralData: { from: number; to: number };\n  nbPeaks: number;\n  multiplicity: string;\n  pattern: string;\n  observe: number;\n};\n\nfunction createSignals2D(peaksInput: MPFPeak[], options: any) {\n  let { observedFrequencies, tolerances, nuclei, dx, dy } = options;\n\n  const peaks: Peak2DHack[] = JSON.parse(JSON.stringify(peaksInput));\n\n  let [nucleusX, nucleusY] = nuclei;\n  let [toleranceX, toleranceY] = tolerances;\n  let [observeFrequencyX, observeFrequencyY] = observedFrequencies;\n\n  // The connectivity matrix is an square and symmetric matrix, so we'll only store the upper diagonal in an\n  // array like form\n  let connectivity = [];\n  for (let i = 0; i < peaks.length; i++) {\n    for (let j = i; j < peaks.length; j++) {\n      if (\n        Math.abs(peaks[i].x - peaks[j].x) * observeFrequencyX < toleranceX &&\n        Math.abs(peaks[i].y - peaks[j].y) * observeFrequencyY < toleranceY\n      ) {\n        // 24*24Hz We cannot distinguish peaks with less than 20 Hz of separation\n        connectivity.push(1);\n      } else {\n        connectivity.push(0);\n      }\n    }\n  }\n  let clusters = simpleClustering(connectivity);\n\n  let signals = [];\n  if (clusters) {\n    for (let cluster of clusters) {\n      let signal: any = {\n        nucleusX,\n        nucleusY,\n        integralData: {\n          from: Number.MAX_SAFE_INTEGER,\n          to: Number.MIN_SAFE_INTEGER,\n        },\n        nbPeaks: 0,\n        multiplicity: '',\n        pattern: '',\n        observe: observeFrequencyY,\n        resolutionX: dx,\n        resolutionY: dy,\n        shiftX: 0,\n        shiftY: 0,\n      };\n      let peaks2D = [];\n      let minMax1 = [Number.MAX_VALUE, 0];\n      let minMax2 = [Number.MAX_VALUE, 0];\n      let sumZ = 0;\n      for (let jPeak = cluster.length - 1; jPeak >= 0; jPeak--) {\n        if (cluster[jPeak] === 1) {\n          signal.nbPeaks++;\n          if (!peaks[jPeak].width) peaks[jPeak].width = 0.02;\n          peaks2D.push(peaks[jPeak]);\n          signal.shiftX += peaks[jPeak].x * peaks[jPeak].z;\n          signal.shiftY += peaks[jPeak].y * peaks[jPeak].z;\n          sumZ += peaks[jPeak].z;\n          if (peaks[jPeak].minX < minMax1[0]) {\n            minMax1[0] = peaks[jPeak].minX;\n          }\n          if (peaks[jPeak].maxX > minMax1[1]) {\n            minMax1[1] = peaks[jPeak].maxX;\n          }\n          if (peaks[jPeak].minY < minMax2[0]) {\n            minMax2[0] = peaks[jPeak].minY;\n          }\n          if (peaks[jPeak].maxY > minMax2[1]) {\n            minMax2[1] = peaks[jPeak].maxY;\n          }\n        }\n      }\n\n      signal.fromTo = [\n        { from: minMax1[0], to: minMax1[1] },\n        { from: minMax2[0], to: minMax2[1] },\n      ];\n      signal.shiftX /= sumZ;\n      signal.shiftY /= sumZ;\n      signal.delta1 = signal.shiftY;\n      signal.peaks = peaks2D;\n      signals.push(signal as Signal2DHack);\n    }\n  }\n  return signals;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\rangesToXY.ts",["454","455","456","457"],"import { DoubleArray } from 'cheminfo-types';\nimport arraySequentialFill from 'ml-array-sequential-fill';\nimport { SpectrumGenerator } from 'spectrum-generator';\nimport type { Shape1DOption } from 'spectrum-generator';\n\nimport { hackSignalsToXY } from '../signals/hackSignalsToXY';\nimport type { MakeMandatory } from '../types/MakeMandatory';\nimport type { NMRRange } from '../types/NMRRange';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\n\n\ntype rangeWithSignal = MakeMandatory<NMRRange, 'signals'>;\n\nexport interface RangeToXYOptions {\n  /**\n   * frequency observed\n   * @default 400\n   */\n  frequency: number;\n  /**\n   * line width to draw the signals\n   * @default 1\n   */\n  lineWidth: number;\n  /**\n   * lower limit in the spectrum.\n   * @default 0\n   */\n  from: number;\n  /**\n   * upper limit in the spectrum.\n   * @default 10\n   */\n  to: number;\n  /**\n   * number of points of the spectrum.\n   * @default 16384\n   */\n  nbPoints: number;\n  /**\n   * options of signals.\n   * @default { kind: 'gaussian' }\n   */\n  shape: Shape1DOption;\n}\nfunction checkForSignals(\n  ranges: NMRRange[],\n): asserts ranges is rangeWithSignal[] {\n  for (let range of ranges) {\n    if (!range.signals) throw new Error('range has not signals');\n  }\n}\nexport function rangesToXY(ranges: NMRRange[], options: any = {}) {\n  checkForSignals(ranges);\n  let {\n    frequency = 400,\n    lineWidth = 1,\n    from = 0,\n    to = 10,\n    nbPoints = 16 * 1024,\n    shape = { kind: 'gaussian' },\n  } = options;\n\n  const addSpectrum = (a: DoubleArray, b: DoubleArray) => {\n    for (let i = 0; i < nbPoints; i++) {\n      a[i] += b[i];\n    }\n  };\n\n  const spectrumOptions = {\n    from,\n    to,\n    nbPoints,\n    shape,\n    lineWidth,\n    frequency,\n  };\n\n  let spectrum: DoubleArray = new Float64Array(nbPoints);\n  for (const range of ranges) {\n    const { integration, signals } = range;\n    let rangeSpectrum: DoubleArray = new Float64Array(nbPoints);\n    for (const signal of signals) {\n      const { multiplicity } = signal;\n      let signalSpectrum =\n        multiplicity === 'm' || multiplicity === 'b' || multiplicity === 'br s'\n          ? broadPeakOrMultipletSpectrum([signal], spectrumOptions).y\n          : hackSignalsToXY([signal], spectrumOptions).y;\n      normalizeSpectrum(signalSpectrum, [signal]);\n      addSpectrum(rangeSpectrum, signalSpectrum);\n    }\n    if (range.integration) {\n      normalizeSpectrum(rangeSpectrum, signals, { integration });\n    }\n    addSpectrum(spectrum, rangeSpectrum);\n  }\n\n  return {\n    x: arraySequentialFill({ from, to, size: nbPoints }),\n    y: spectrum,\n  };\n}\n\nfunction broadPeakOrMultipletSpectrum(\n  signals: NMRSignal1D[],\n  options: any = {},\n) {\n  const { lineWidth, frequency } = options;\n  const spectrumGenerator = new SpectrumGenerator(options);\n\n  const broadWidth = (lineWidth * 3) / frequency;\n  for (let signal of signals) {\n    const { multiplicity, delta, integration = 1 } = signal;\n    if (multiplicity === 'b' || multiplicity === 'br s') {\n      spectrumGenerator.addPeak({\n        x: delta,\n        y: integration,\n        width: broadWidth,\n      });\n    } else {\n      const peaks = peaksOfMultiplet(delta, {\n        lineWidth,\n        frequency,\n      });\n      spectrumGenerator.addPeaks(peaks);\n    }\n  }\n  return spectrumGenerator.getSpectrum();\n}\n\nfunction peaksOfMultiplet(delta: number, options: any) {\n  const {\n    frequency,\n    lineWidth,\n    intensities = [1, 2, 5, 4, 5, 3, 4, 2, 1],\n  } = options;\n\n  const lineWidthPpm = lineWidth / frequency;\n  const spaceBetweenPeaks = lineWidthPpm * 1.5;\n\n  const peaks = [];\n  const firstPeakPosition =\n    delta - (spaceBetweenPeaks * intensities.length) / 2;\n  for (let i = 0; i < intensities.length; i++) {\n    peaks.push({\n      x: firstPeakPosition + spaceBetweenPeaks * i,\n      y: intensities[i],\n      width: lineWidthPpm,\n    });\n  }\n\n  return peaks;\n}\n\nfunction normalizeSpectrum(\n  spectrum: DoubleArray,\n  signals: NMRSignal1D[],\n  options: any = {},\n) {\n  const {\n    integration = signals.reduce((acc, signal) => {\n      const { integration = 1 } = signal;\n      return acc + integration;\n    }, 0),\n  } = options;\n  const sum = (spectrum as Float64Array).reduce(\n    (acc: number, element: number) => acc + element,\n    0,\n  );\n\n  const norma = (integration / sum) * 1e6;\n  if (sum !== 0) {\n    for (let i = 0; i < spectrum.length; i++) {\n      spectrum[i] *= norma;\n    }\n  }\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\ranges\\__tests__\\rangesToXY.test.ts",["458"],"import { resurrect } from '../..';\nimport { xyAutoPeaksPicking } from '../../xy/xyAutoPeaksPicking';\nimport { rangesToXY } from '../rangesToXY';\n\ndescribe('general test', () => {\n  it('s, br s', () => {\n    const ranges = [\n      {\n        from: 1,\n        to: 1.5,\n        signals: [\n          {\n            delta: 1.25,\n            multiplicity: 's',\n          },\n        ],\n      },\n      {\n        from: 1.5,\n        to: 1.7,\n        signals: [\n          {\n            delta: 1.6,\n            multiplicity: 'b',\n          },\n        ],\n      },\n    ];\n\n    const spectrum = rangesToXY(ranges, { nbPoints: 1024, from: 1, to: 1.7 });\n    const peaks = xyAutoPeaksPicking(spectrum);\n    expect(peaks).toHaveLength(2);\n  });\n\n  it('d, m', () => {\n    const ranges = [\n      {\n        from: 1,\n        to: 1.5,\n        signals: [\n          {\n            delta: 1.25,\n            multiplicity: 'd',\n            js: [{ coupling: 16, multiplicity: 'd' }],\n          },\n        ],\n      },\n      {\n        from: 1.55,\n        to: 1.7,\n        signals: [\n          {\n            delta: 1.6,\n            multiplicity: 'm',\n          },\n        ],\n      },\n    ];\n\n    const spectrum = rangesToXY(ranges, { nbPoints: 1024, from: 1.1, to: 1.7 });\n    const peaks = xyAutoPeaksPicking(spectrum);\n    expect(peaks).toHaveLength(11);\n  });\n  it.skip('from ACS', () => {\n    const acs = `1H NMR (CDCl3, 400 MHz) d: 5.55 (d, J = 8.1 Hz, 1H, H-10 ), 4.72 (br s, 1H),\n    4.29 (m, 1H, H-50 ), 3.53 (m, 2H, H-30 , H-40 ), 3.42  \n    (m, 1H, H-20 ), 3.15 (dd, J = 6.0 Hz, J = 10.0 Hz, 1H, H-3), 3.00 (td, J = 11.0 Hz,  \n    J = 4.5 Hz, 1H, H-19), 1.69 (s, 1H, H-30)`;\n    const ranges = resurrect(acs);\n    expect(ranges).toHaveLength(7);\n  });\n});\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\resurrectRange.ts",["459","460","461","462","463"],"import type { NMRRange } from '../types/NMRRange';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\n\nimport { rangeFromSignal } from './rangeFromSignal';\nimport { splitParenthesis } from './splitParenthesis';\nimport { splitPatterns } from './splitPatterns';\n\nexport function resurrectRange(part: string, options: any = {}) {\n  const { nucleus = '1h', frequency = 400 } = options;\n  const split = splitParenthesis(part);\n  if (!split.before) return;\n  // before parenthesis there should be only numbers but we will still split with space\n  const beforeParts = split.before\n    .split(/(?: |(?<=[0-9])-)/)\n    .map((part: string) => Number(part))\n    .filter((part: number) => !Number.isNaN(part));\n  if (beforeParts.length < 1 || beforeParts.length > 2) {\n    return;\n  }\n  const from = beforeParts[0];\n  const to = beforeParts.length > 1 ? beforeParts[1] : beforeParts[0];\n\n  const insideParts = split.inside.split(/ *, */);\n  let signal: NMRSignal1D = { delta: NaN, js: [] };\n  let range: NMRRange = { from, to, signals: [signal] };\n\n  const integrationParts = insideParts.filter((part: any) =>\n    part.match(/^[0-9]+H$/),\n  );\n  if (integrationParts.length === 1) {\n    range.integration = Number(integrationParts[0].replace('H', ''));\n  }\n\n  const multiplicityParts = insideParts.filter((part: any) =>\n    part.match(/^[a-zA-Z]+$/),\n  );\n  if (multiplicityParts.length === 1) {\n    const multiplicity = multiplicityParts[0];\n    if (multiplicity === 'm') {\n      if (beforeParts.length === 1) {\n        // a complex signal\n        signal.delta = beforeParts[0];\n        signal.multiplicity = multiplicity;\n      } else {\n        // a real range\n        signal.delta = (beforeParts[0] + beforeParts[1]) / 2;\n        signal.multiplicity = multiplicity;\n      }\n    } else {\n      // looks like a real multiplicity, s, d, dd, etc..\n      if (beforeParts.length === 1) {\n        // a complex signal\n        signal.delta = beforeParts[0];\n        signal.multiplicity = multiplicity;\n      }\n    }\n  }\n\n  const jCouplings = insideParts\n    .filter((part: any) => part.match(/(Hz|J|^[0-9.]+$)/))\n    .map((jCoupling: string) => Number(jCoupling.replace(/[^0-9.]/g, '')));\n\n  const multiplicities = splitPatterns(signal.multiplicity || '');\n  if (multiplicities.length === jCouplings.length) {\n    for (let i = 0; i < multiplicities.length; i++) {\n      if (!signal.js) {\n        throw new Error('signal has not js');\n      }\n      signal.js.push({\n        coupling: jCouplings[i],\n        multiplicity: multiplicities[i],\n      });\n    }\n  }\n\n  if (range.from === range.to) {\n    range = { ...range, ...rangeFromSignal(signal, { nucleus, frequency }) };\n  }\n\n  return range;\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\splitParenthesis.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\resurrectRange.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\carbonImpurities.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\DatabaseNMREntry.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\getDatabase.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\protonImpurities.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\databases\\__tests__\\getDatabase.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\prediction\\utils\\getNuclei.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\rangeFromSignal.ts",["464"],"import { couplingValues } from '../constants/couplingValues';\nimport type { NMRSignal1D } from '../types/NMRSignal1D';\n\nexport interface RangeFromSignalOptions {\n  /**\n   * nucleus\n   * @default '1h'\n   */\n  nucleus: string;\n  /**\n   * frequency observed\n   * @default 400\n   */\n  frequency: number;\n}\n\nexport function rangeFromSignal(signal: NMRSignal1D, options: any = {}) {\n  const { nucleus = '1h', frequency = 400 } = options;\n  const { tolerance = getTolerance(nucleus) / frequency } = options;\n  let halfWidth =\n    (signal.js || []).reduce((total, j) => {\n      const { coupling, multiplicity = 'd' } = j;\n      return total + (couplingValues[multiplicity] * coupling) / frequency;\n    }, 0) /\n      2 +\n    tolerance;\n  return {\n    from: signal.delta - halfWidth,\n    to: signal.delta + halfWidth,\n  };\n}\n\nfunction getTolerance(nucleus: string) {\n  switch (nucleus.toLocaleLowerCase()) {\n    case '1h':\n      return 1.5;\n    case '13C':\n      return 3;\n    default:\n      return 2;\n  }\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\utilities\\__tests__\\rangeFromSignal.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\__tests__\\index.test.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-gsd\\index.d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\ml-levenberg-marquardt\\index.d.ts",["465"],"declare module 'ml-levenberg-marquardt' {\n  import type { DataXY } from 'cheminfo-types';\n\n  export default function levenbergMarquardt(\n    data: DataXY,\n    parametrizedFunction: (p: number[]) => (t: number) => number,\n    options?: any,\n  ): {\n    parameterValues: Array<number>;\n    parameterError: number;\n    iterations: number;\n  };\n}\n","C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\dataStructure.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\jcoupling.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\MakeMandatory.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\MPFPeak.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\nmrAssigment.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRPeak1D.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRRange.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRSignal1D.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRSignal2D.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\NMRZone.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\openchemlib-utils\\index..d.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\prediction1D.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\prediction2D.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\spinSystem.ts",[],"C:\\Users\\alejo\\git\\cheminfo\\nmr-processing_alt\\src\\types\\XYNumberArray.ts",[],{"ruleId":"466","severity":1,"message":"467","line":4,"column":1,"nodeType":"468","messageId":"469","endLine":4,"endColumn":66},{"ruleId":"470","severity":1,"message":"471","line":249,"column":26,"nodeType":"472","messageId":"473","endLine":249,"endColumn":29,"suggestions":"474"},{"ruleId":"466","severity":1,"message":"475","line":375,"column":62,"nodeType":"468","messageId":"469","endLine":375,"endColumn":112},{"ruleId":"470","severity":1,"message":"471","line":15,"column":61,"nodeType":"472","messageId":"473","endLine":15,"endColumn":64,"suggestions":"476"},{"ruleId":"470","severity":1,"message":"471","line":103,"column":18,"nodeType":"472","messageId":"473","endLine":103,"endColumn":21,"suggestions":"477"},{"ruleId":"470","severity":1,"message":"471","line":106,"column":18,"nodeType":"472","messageId":"473","endLine":106,"endColumn":21,"suggestions":"478"},{"ruleId":"479","severity":1,"message":"480","line":48,"column":7,"nodeType":"468","messageId":"481","endLine":48,"endColumn":25},{"ruleId":"470","severity":1,"message":"471","line":37,"column":11,"nodeType":"472","messageId":"473","endLine":37,"endColumn":14,"suggestions":"482"},{"ruleId":"483","severity":1,"message":"484","line":15,"column":7,"nodeType":"485","messageId":"486","endLine":15,"endColumn":38,"suggestions":"487"},{"ruleId":"470","severity":1,"message":"471","line":220,"column":17,"nodeType":"472","messageId":"473","endLine":220,"endColumn":20,"suggestions":"488"},{"ruleId":"470","severity":1,"message":"471","line":221,"column":19,"nodeType":"472","messageId":"473","endLine":221,"endColumn":22,"suggestions":"489"},{"ruleId":"470","severity":1,"message":"471","line":284,"column":17,"nodeType":"472","messageId":"473","endLine":284,"endColumn":20,"suggestions":"490"},{"ruleId":"470","severity":1,"message":"471","line":286,"column":15,"nodeType":"472","messageId":"473","endLine":286,"endColumn":18,"suggestions":"491"},{"ruleId":"470","severity":1,"message":"471","line":36,"column":40,"nodeType":"472","messageId":"473","endLine":36,"endColumn":43,"suggestions":"492"},{"ruleId":"479","severity":1,"message":"480","line":66,"column":3,"nodeType":"468","messageId":"481","endLine":66,"endColumn":21},{"ruleId":"470","severity":1,"message":"471","line":90,"column":49,"nodeType":"472","messageId":"473","endLine":90,"endColumn":52,"suggestions":"493"},{"ruleId":"470","severity":1,"message":"471","line":105,"column":38,"nodeType":"472","messageId":"473","endLine":105,"endColumn":41,"suggestions":"494"},{"ruleId":"470","severity":1,"message":"471","line":122,"column":67,"nodeType":"472","messageId":"473","endLine":122,"endColumn":70,"suggestions":"495"},{"ruleId":"470","severity":1,"message":"471","line":124,"column":20,"nodeType":"472","messageId":"473","endLine":124,"endColumn":23,"suggestions":"496"},{"ruleId":"470","severity":1,"message":"471","line":177,"column":19,"nodeType":"472","messageId":"473","endLine":177,"endColumn":22,"suggestions":"497"},{"ruleId":"470","severity":1,"message":"471","line":184,"column":48,"nodeType":"472","messageId":"473","endLine":184,"endColumn":51,"suggestions":"498"},{"ruleId":"470","severity":1,"message":"471","line":196,"column":72,"nodeType":"472","messageId":"473","endLine":196,"endColumn":75,"suggestions":"499"},{"ruleId":"470","severity":1,"message":"471","line":220,"column":12,"nodeType":"472","messageId":"473","endLine":220,"endColumn":15,"suggestions":"500"},{"ruleId":"470","severity":1,"message":"471","line":266,"column":12,"nodeType":"472","messageId":"473","endLine":266,"endColumn":15,"suggestions":"501"},{"ruleId":"470","severity":1,"message":"471","line":70,"column":15,"nodeType":"472","messageId":"473","endLine":70,"endColumn":18,"suggestions":"502"},{"ruleId":"479","severity":1,"message":"480","line":135,"column":7,"nodeType":"468","messageId":"481","endLine":135,"endColumn":25},{"ruleId":"470","severity":1,"message":"471","line":19,"column":15,"nodeType":"472","messageId":"473","endLine":19,"endColumn":18,"suggestions":"503"},{"ruleId":"504","severity":1,"message":"505","line":58,"column":46,"nodeType":"506","messageId":"507","endLine":58,"endColumn":71},{"ruleId":"504","severity":1,"message":"508","line":58,"column":46,"nodeType":"506","messageId":"507","endLine":58,"endColumn":71},{"ruleId":"470","severity":1,"message":"471","line":72,"column":14,"nodeType":"472","messageId":"473","endLine":72,"endColumn":17,"suggestions":"509"},{"ruleId":"504","severity":1,"message":"510","line":83,"column":33,"nodeType":"506","messageId":"507","endLine":83,"endColumn":48},{"ruleId":"504","severity":1,"message":"510","line":88,"column":33,"nodeType":"506","messageId":"507","endLine":88,"endColumn":48},{"ruleId":"504","severity":1,"message":"511","line":4,"column":5,"nodeType":"506","messageId":"507","endLine":4,"endColumn":60},{"ruleId":"512","severity":1,"message":"513","line":6,"column":3,"nodeType":"514","messageId":"515","endLine":15,"endColumn":5},{"ruleId":"512","severity":1,"message":"513","line":17,"column":3,"nodeType":"514","messageId":"515","endLine":24,"endColumn":5},{"ruleId":"512","severity":1,"message":"513","line":37,"column":3,"nodeType":"514","messageId":"515","endLine":47,"endColumn":5},{"ruleId":"470","severity":1,"message":"471","line":45,"column":44,"nodeType":"472","messageId":"473","endLine":45,"endColumn":47,"suggestions":"516"},{"ruleId":"470","severity":1,"message":"471","line":274,"column":19,"nodeType":"472","messageId":"473","endLine":274,"endColumn":22,"suggestions":"517"},{"ruleId":"470","severity":1,"message":"471","line":152,"column":58,"nodeType":"472","messageId":"473","endLine":152,"endColumn":61,"suggestions":"518"},{"ruleId":"470","severity":1,"message":"471","line":182,"column":19,"nodeType":"472","messageId":"473","endLine":182,"endColumn":22,"suggestions":"519"},{"ruleId":"470","severity":1,"message":"471","line":53,"column":57,"nodeType":"472","messageId":"473","endLine":53,"endColumn":60,"suggestions":"520"},{"ruleId":"470","severity":1,"message":"471","line":106,"column":12,"nodeType":"472","messageId":"473","endLine":106,"endColumn":15,"suggestions":"521"},{"ruleId":"470","severity":1,"message":"471","line":131,"column":51,"nodeType":"472","messageId":"473","endLine":131,"endColumn":54,"suggestions":"522"},{"ruleId":"470","severity":1,"message":"471","line":158,"column":12,"nodeType":"472","messageId":"473","endLine":158,"endColumn":15,"suggestions":"523"},{"ruleId":"512","severity":1,"message":"513","line":64,"column":3,"nodeType":"514","messageId":"515","endLine":71,"endColumn":5},{"ruleId":"470","severity":1,"message":"471","line":8,"column":55,"nodeType":"472","messageId":"473","endLine":8,"endColumn":58,"suggestions":"524"},{"ruleId":"470","severity":1,"message":"471","line":27,"column":54,"nodeType":"472","messageId":"473","endLine":27,"endColumn":57,"suggestions":"525"},{"ruleId":"470","severity":1,"message":"471","line":34,"column":55,"nodeType":"472","messageId":"473","endLine":34,"endColumn":58,"suggestions":"526"},{"ruleId":"470","severity":1,"message":"471","line":60,"column":20,"nodeType":"472","messageId":"473","endLine":60,"endColumn":23,"suggestions":"527"},{"ruleId":"504","severity":1,"message":"528","line":60,"column":39,"nodeType":"506","messageId":"507","endLine":60,"endColumn":57},{"ruleId":"470","severity":1,"message":"471","line":17,"column":63,"nodeType":"472","messageId":"473","endLine":17,"endColumn":66,"suggestions":"529"},{"ruleId":"470","severity":1,"message":"471","line":7,"column":15,"nodeType":"472","messageId":"473","endLine":7,"endColumn":18,"suggestions":"530"},"no-warning-comments","Unexpected 'todo' comment: 'TODO: #13 can we have a better source...'.","Line","unexpectedComment","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["531","532"],"Unexpected 'todo' comment: 'todo add an option with this value:...'.",["533","534"],["535","536"],["537","538"],"@typescript-eslint/ban-ts-comment","Include a description after the \"@ts-expect-error\" directive to explain why the @ts-expect-error is necessary. The description must be 3 characters or longer.","tsDirectiveCommentRequiresDescription",["539","540"],"@typescript-eslint/prefer-optional-chain","Prefer using an optional chain expression instead, as it's more concise and easier to read.","LogicalExpression","preferOptionalChain",["541"],["542","543"],["544","545"],["546","547"],["548","549"],["550","551"],["552","553"],["554","555"],["556","557"],["558","559"],["560","561"],["562","563"],["564","565"],["566","567"],["568","569"],["570","571"],["572","573"],"prefer-named-capture-group","Capture group '([A-Z][a-z]?)' should be converted to a named or non-capturing group.","Literal","required","Capture group '([0-9]+)' should be converted to a named or non-capturing group.",["574","575"],"Capture group '(.*?)' should be converted to a named or non-capturing group.","Capture group '(quint|hex|sept|hept|oct|nona|non|s|d|t|q|h|o|n)' should be converted to a named or non-capturing group.","jest/no-disabled-tests","Skipped test","CallExpression","skippedTest",["576","577"],["578","579"],["580","581"],["582","583"],["584","585"],["586","587"],["588","589"],["590","591"],["592","593"],["594","595"],["596","597"],["598","599"],"Capture group '(Hz|J|^[0-9.]+$)' should be converted to a named or non-capturing group.",["600","601"],["602","603"],{"messageId":"604","fix":"605","desc":"606"},{"messageId":"607","fix":"608","desc":"609"},{"messageId":"604","fix":"610","desc":"606"},{"messageId":"607","fix":"611","desc":"609"},{"messageId":"604","fix":"612","desc":"606"},{"messageId":"607","fix":"613","desc":"609"},{"messageId":"604","fix":"614","desc":"606"},{"messageId":"607","fix":"615","desc":"609"},{"messageId":"604","fix":"616","desc":"606"},{"messageId":"607","fix":"617","desc":"609"},{"messageId":"618","fix":"619","desc":"620"},{"messageId":"604","fix":"621","desc":"606"},{"messageId":"607","fix":"622","desc":"609"},{"messageId":"604","fix":"623","desc":"606"},{"messageId":"607","fix":"624","desc":"609"},{"messageId":"604","fix":"625","desc":"606"},{"messageId":"607","fix":"626","desc":"609"},{"messageId":"604","fix":"627","desc":"606"},{"messageId":"607","fix":"628","desc":"609"},{"messageId":"604","fix":"629","desc":"606"},{"messageId":"607","fix":"630","desc":"609"},{"messageId":"604","fix":"631","desc":"606"},{"messageId":"607","fix":"632","desc":"609"},{"messageId":"604","fix":"633","desc":"606"},{"messageId":"607","fix":"634","desc":"609"},{"messageId":"604","fix":"635","desc":"606"},{"messageId":"607","fix":"636","desc":"609"},{"messageId":"604","fix":"637","desc":"606"},{"messageId":"607","fix":"638","desc":"609"},{"messageId":"604","fix":"639","desc":"606"},{"messageId":"607","fix":"640","desc":"609"},{"messageId":"604","fix":"641","desc":"606"},{"messageId":"607","fix":"642","desc":"609"},{"messageId":"604","fix":"643","desc":"606"},{"messageId":"607","fix":"644","desc":"609"},{"messageId":"604","fix":"645","desc":"606"},{"messageId":"607","fix":"646","desc":"609"},{"messageId":"604","fix":"647","desc":"606"},{"messageId":"607","fix":"648","desc":"609"},{"messageId":"604","fix":"649","desc":"606"},{"messageId":"607","fix":"650","desc":"609"},{"messageId":"604","fix":"651","desc":"606"},{"messageId":"607","fix":"652","desc":"609"},{"messageId":"604","fix":"653","desc":"606"},{"messageId":"607","fix":"654","desc":"609"},{"messageId":"604","fix":"655","desc":"606"},{"messageId":"607","fix":"656","desc":"609"},{"messageId":"604","fix":"657","desc":"606"},{"messageId":"607","fix":"658","desc":"609"},{"messageId":"604","fix":"659","desc":"606"},{"messageId":"607","fix":"660","desc":"609"},{"messageId":"604","fix":"661","desc":"606"},{"messageId":"607","fix":"662","desc":"609"},{"messageId":"604","fix":"663","desc":"606"},{"messageId":"607","fix":"664","desc":"609"},{"messageId":"604","fix":"665","desc":"606"},{"messageId":"607","fix":"666","desc":"609"},{"messageId":"604","fix":"667","desc":"606"},{"messageId":"607","fix":"668","desc":"609"},{"messageId":"604","fix":"669","desc":"606"},{"messageId":"607","fix":"670","desc":"609"},{"messageId":"604","fix":"671","desc":"606"},{"messageId":"607","fix":"672","desc":"609"},{"messageId":"604","fix":"673","desc":"606"},{"messageId":"607","fix":"674","desc":"609"},{"messageId":"604","fix":"675","desc":"606"},{"messageId":"607","fix":"676","desc":"609"},{"messageId":"604","fix":"677","desc":"606"},{"messageId":"607","fix":"678","desc":"609"},{"messageId":"604","fix":"679","desc":"606"},{"messageId":"607","fix":"680","desc":"609"},{"messageId":"604","fix":"681","desc":"606"},{"messageId":"607","fix":"682","desc":"609"},"suggestUnknown",{"range":"683","text":"684"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"683","text":"685"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"686","text":"684"},{"range":"686","text":"685"},{"range":"687","text":"684"},{"range":"687","text":"685"},{"range":"688","text":"684"},{"range":"688","text":"685"},{"range":"689","text":"684"},{"range":"689","text":"685"},"optionalChainSuggest",{"range":"690","text":"691"},"Change to an optional chain.",{"range":"692","text":"684"},{"range":"692","text":"685"},{"range":"693","text":"684"},{"range":"693","text":"685"},{"range":"694","text":"684"},{"range":"694","text":"685"},{"range":"695","text":"684"},{"range":"695","text":"685"},{"range":"696","text":"684"},{"range":"696","text":"685"},{"range":"697","text":"684"},{"range":"697","text":"685"},{"range":"698","text":"684"},{"range":"698","text":"685"},{"range":"699","text":"684"},{"range":"699","text":"685"},{"range":"700","text":"684"},{"range":"700","text":"685"},{"range":"701","text":"684"},{"range":"701","text":"685"},{"range":"702","text":"684"},{"range":"702","text":"685"},{"range":"703","text":"684"},{"range":"703","text":"685"},{"range":"704","text":"684"},{"range":"704","text":"685"},{"range":"705","text":"684"},{"range":"705","text":"685"},{"range":"706","text":"684"},{"range":"706","text":"685"},{"range":"707","text":"684"},{"range":"707","text":"685"},{"range":"708","text":"684"},{"range":"708","text":"685"},{"range":"709","text":"684"},{"range":"709","text":"685"},{"range":"710","text":"684"},{"range":"710","text":"685"},{"range":"711","text":"684"},{"range":"711","text":"685"},{"range":"712","text":"684"},{"range":"712","text":"685"},{"range":"713","text":"684"},{"range":"713","text":"685"},{"range":"714","text":"684"},{"range":"714","text":"685"},{"range":"715","text":"684"},{"range":"715","text":"685"},{"range":"716","text":"684"},{"range":"716","text":"685"},{"range":"717","text":"684"},{"range":"717","text":"685"},{"range":"718","text":"684"},{"range":"718","text":"685"},{"range":"719","text":"684"},{"range":"719","text":"685"},{"range":"720","text":"684"},{"range":"720","text":"685"},{"range":"721","text":"684"},{"range":"721","text":"685"},{"range":"722","text":"684"},{"range":"722","text":"685"},[6612,6615],"unknown","never",[546,549],[2873,2876],[2821,2824],[1024,1027],[404,435],"predictions?.[key]",[5446,5449],[5482,5485],[7231,7234],[7270,7273],[1410,1413],[1939,1942],[2329,2332],[2817,2820],[2863,2866],[4789,4792],[5010,5013],[5353,5356],[5974,5977],[7140,7143],[2071,2074],[429,432],[2024,2027],[1470,1473],[7611,7614],[3983,3986],[5016,5019],[1300,1303],[2664,2667],[3351,3354],[3954,3957],[321,324],[1096,1099],[1306,1309],[2061,2064],[365,368],[235,238]]